# Scaffold script generated by Task Writer
# Generated on: 2025-07-01T01:16:16.732Z
# Source directory: /mnt/c/Projects/task-writer/frontend/app/src/hooks
# Target OS: cross-platform
# Directories: 0
# Files: 21
#
# This script will recreate the directory structure and files
# including the original file contents.

# Create files
# Create useBrowserLimitations.ts
cat > "src/hooks/useBrowserLimitations.ts" << 'EOF'
import { useEffect, useCallback } from 'react'
import { useErrorHandler } from '@/hooks/useErrorHandler'
import { getPlatformService } from '@/services/platformService'

interface BrowserLimitationConfig {
  showOnMount?: boolean
  features?: string[]
}

/**
 * Hook for managing browser limitation warnings
 * Automatically shows warnings for limited functionality in browser mode
 */
export const useBrowserLimitations = (config: BrowserLimitationConfig = {}) => {
  const { handleBrowserLimitation } = useErrorHandler()
  const platformService = getPlatformService()

  // Show initial browser limitation warning
  useEffect(() => {
    if (config.showOnMount && platformService.isBrowser()) {
      const features = config.features || [
        'Directory scanning and analysis',
        'Task generation',
        'File system operations',
        'Advanced export options'
      ]

      // Add a small delay to ensure the context is ready
      setTimeout(() => {
        handleBrowserLimitation(
          'Browser Mode - Limited Functionality',
          `${features.join(', ')} are not available in browser mode. Download the desktop application for full functionality.`
        )
      }, 100)
    }
  }, [config.showOnMount, config.features, handleBrowserLimitation, platformService])

  // Function to warn about specific feature limitations
  const warnFeatureLimitation = useCallback((
    feature: string,
    workaround?: string
  ) => {
    if (platformService.isBrowser()) {
      return handleBrowserLimitation(feature, workaround)
    }
    return null
  }, [handleBrowserLimitation, platformService])

  // Check if a feature is available
  const isFeatureAvailable = useCallback((feature: 'directory-scan' | 'task-generation' | 'file-system') => {
    if (platformService.isElectron()) {
      return true
    }

    // Some features might be partially available in browser
    switch (feature) {
      case 'directory-scan':
      case 'task-generation':
        return false
      case 'file-system':
        return 'showDirectoryPicker' in window // Modern browsers with File System Access API
      default:
        return false
    }
  }, [platformService])

  return {
    isBrowser: platformService.isBrowser(),
    isElectron: platformService.isElectron(),
    warnFeatureLimitation,
    isFeatureAvailable,
  }
}

// Specific hooks for different pages/features
export const useTaskGeneratorLimitations = () => {
  return useBrowserLimitations({
    showOnMount: true,
    features: [
      'Directory scanning',
      'Automated task generation',
      'Bulk file operations'
    ]
  })
}

export const useScaffoldGeneratorLimitations = () => {
  return useBrowserLimitations({
    showOnMount: true,
    features: [
      'Scaffold generation',
      'Template processing',
      'File structure creation'
    ]
  })
}
EOF

# Create useErrorHandler.ts
cat > "src/hooks/useErrorHandler.ts" << 'EOF'
import { useCallback } from 'react'
import { useError } from '@/contexts/ErrorContext'
import { useToast } from '@/hooks/useToast'
import type { ErrorType, ErrorPersistence } from '@/contexts/ErrorContext'

interface ErrorHandlerOptions {
  title: string
  message?: string
  type?: ErrorType
  persistence?: ErrorPersistence
  dismissible?: boolean
  action?: {
    label: string
    onClick: () => void
  }
  showToast?: boolean // If true, also show as toast notification
}

interface ValidationError {
  field: string
  message: string
}

interface ServerError {
  code?: string | number
  message: string
  details?: unknown
}

/**
 * Standardized error handling hook
 * Provides consistent error handling across the application
 * Supports both banner errors and toast notifications
 */
export const useErrorHandler = () => {
  const { addError, removeError, clearErrors } = useError()
  const toast = useToast()

  // Generic error handler
  const handleError = useCallback((options: ErrorHandlerOptions) => {
    const errorId = addError({
      title: options.title,
      message: options.message,
      type: options.type || 'error',
      persistence: options.persistence || 'temporary',
      dismissible: options.dismissible ?? true,
      action: options.action,
    })

    // Also show as toast if requested
    if (options.showToast) {
      const toastType = options.type === 'info' ? 'success' : options.type || 'error'
      toast[toastType](options.title, options.message)
    }

    return errorId
  }, [addError, toast])

  // Validation error handler
  const handleValidationError = useCallback((
    field: string, 
    message: string,
    showPersistent = false
  ) => {
    return handleError({
      title: `Validation Error: ${field}`,
      message,
      type: 'warning',
      persistence: showPersistent ? 'persistent' : 'temporary',
      showToast: !showPersistent,
    })
  }, [handleError])

  // Multiple validation errors handler
  const handleValidationErrors = useCallback((
    errors: ValidationError[],
    showPersistent = false
  ) => {
    if (errors.length === 0) return []

    // For multiple errors, show the first one prominently
    const firstError = errors[0]
    const remainingCount = errors.length - 1

    const title = `Validation Error: ${firstError.field}`
    const message = remainingCount > 0 
      ? `${firstError.message} (and ${remainingCount} more error${remainingCount !== 1 ? 's' : ''})`
      : firstError.message

    return [handleError({
      title,
      message,
      type: 'warning',
      persistence: showPersistent ? 'persistent' : 'temporary',
      showToast: !showPersistent,
    })]
  }, [handleError])

  // Server error handler
  const handleServerError = useCallback((
    error: ServerError,
    context = 'Server Error'
  ) => {
    const title = error.code ? `${context} (${error.code})` : context
    
    return handleError({
      title,
      message: error.message,
      type: 'error',
      persistence: 'persistent',
      dismissible: true,
    })
  }, [handleError])

  // Network error handler
  const handleNetworkError = useCallback((
    message = 'Unable to connect to server. Please check your internet connection.',
    showRetryAction = true
  ) => {
    return handleError({
      title: 'Network Error',
      message,
      type: 'error',
      persistence: 'persistent',
      action: showRetryAction ? {
        label: 'Retry',
        onClick: () => window.location.reload()
      } : undefined,
    })
  }, [handleError])

  // Browser limitation warning
  const handleBrowserLimitation = useCallback((
    feature: string,
    workaround?: string
  ) => {
    const message = workaround 
      ? `${feature} is not available in browser mode. ${workaround}`
      : `${feature} is not available in browser mode. Please use the desktop application for full functionality.`

    return handleError({
      title: 'Browser Limitation',
      message,
      type: 'warning',
      persistence: 'session',
      action: {
        label: 'Learn More',
        onClick: () => {
          // Could open documentation or help
          console.info('Browser limitations help requested')
        }
      }
    })
  }, [handleError])

  // Permission error handler
  const handlePermissionError = useCallback((
    resource: string,
    required: string
  ) => {
    return handleError({
      title: 'Permission Denied',
      message: `Access to ${resource} requires ${required} permission.`,
      type: 'error',
      persistence: 'persistent',
    })
  }, [handleError])

  // Clear specific error types
  const clearErrorsByType = useCallback((type: ErrorType) => {
    clearErrors(type)
  }, [clearErrors])

  // Clear all temporary errors (useful for page transitions)
  const clearTemporaryErrors = useCallback(() => {
    clearErrors('error') // Assuming temporary errors are mostly 'error' type
  }, [clearErrors])

  return {
    // Generic handlers
    handleError,
    
    // Specific error handlers
    handleValidationError,
    handleValidationErrors,
    handleServerError,
    handleNetworkError,
    handleBrowserLimitation,
    handlePermissionError,
    
    // Error management
    removeError,
    clearErrorsByType,
    clearTemporaryErrors,
  }
}
EOF

# Create useFileTreeState.ts
cat > "src/hooks/useFileTreeState.ts" << 'EOF'
import { useState, useCallback } from 'react'
import { updateNodeExpanded, type TreeNode } from '@/utils/fileTreeUtils'

interface UseFileTreeStateProps {
  initialNodes: TreeNode[]
  onNodeSelect?: (node: TreeNode) => void
  onNodeToggle?: (node: TreeNode) => void
}

/**
 * Custom hook for managing FileTree state
 * Follows architecture guide principles:
 * - Single responsibility: File tree state management
 * - Clean separation from UI logic
 * - Reusable state logic
 */
export const useFileTreeState = ({
  initialNodes,
  onNodeSelect,
  onNodeToggle,
}: UseFileTreeStateProps) => {
  const [nodes, setNodes] = useState<TreeNode[]>(initialNodes)
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null)

  const handleNodeSelect = useCallback((node: TreeNode) => {
    setSelectedNodeId(node.id)
    onNodeSelect?.(node)
  }, [onNodeSelect])

  const handleNodeToggle = useCallback((node: TreeNode) => {
    const newExpanded = !node.expanded
    
    // Update local state
    setNodes(prevNodes => updateNodeExpanded(prevNodes, node.id, newExpanded))
    
    // Notify parent component
    onNodeToggle?.({ ...node, expanded: newExpanded })
  }, [onNodeToggle])

  const updateNodes = useCallback((newNodes: TreeNode[]) => {
    setNodes(newNodes)
  }, [])

  const resetSelection = useCallback(() => {
    setSelectedNodeId(null)
  }, [])

  return {
    nodes,
    selectedNodeId,
    handleNodeSelect,
    handleNodeToggle,
    updateNodes,
    resetSelection,
  }
}
EOF

# Create useKeyboardShortcuts.ts
cat > "src/hooks/useKeyboardShortcuts.ts" << 'EOF'
import { useEffect, useCallback } from 'react'
import { usePlatform } from './usePlatform'

interface KeyboardShortcuts {
  onOpenSearch: () => void
}

export const useKeyboardShortcuts = ({ onOpenSearch }: KeyboardShortcuts) => {
  const platformService = usePlatform()

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    // Check for search shortcut: Ctrl+F (Windows/Linux) or Cmd+F (Mac)
    const isSearchShortcut = platformService.isMac() 
      ? event.metaKey && event.key === 'f'
      : event.ctrlKey && event.key === 'f'

    if (isSearchShortcut) {
      // Prevent browser's default search behavior
      event.preventDefault()
      event.stopPropagation()
      onOpenSearch()
      return
    }

    // Additional shortcuts can be added here in the future
  }, [onOpenSearch, platformService])

  useEffect(() => {
    // Add event listener
    document.addEventListener('keydown', handleKeyDown, true)
    
    // Cleanup
    return () => {
      document.removeEventListener('keydown', handleKeyDown, true)
    }
  }, [handleKeyDown])
}

export default useKeyboardShortcuts
EOF

# Create useLayoutEffects.ts
cat > "src/hooks/useLayoutEffects.ts" << 'EOF'
import { useEffect } from 'react'

interface UseLayoutEffectsParams {
  activeTabId: string | null
  activeTab: string
  updateSetting: (key: string, value: any) => void
  currentTabHasPanel: boolean
  isExpanded: boolean
}

/**
 * Custom hook for managing layout-specific side effects
 * Handles synchronization and auto-behaviors
 */
export const useLayoutEffects = ({
  activeTabId,
  activeTab,
  updateSetting,
  currentTabHasPanel,
  isExpanded,
}: UseLayoutEffectsParams) => {

  // Sync sidebar active tab with actual active tab
  useEffect(() => {
    if (activeTabId && activeTabId !== activeTab) {
      updateSetting('activeSidebarTab', activeTabId)
    }
    // Clear sidebar active tab when no tabs are open
    if (!activeTabId && activeTab) {
      updateSetting('activeSidebarTab', '')
    }
  }, [activeTabId, activeTab, updateSetting])

  // Auto-collapse panel when switching to a tab that doesn't have a panel or when no active tab
  useEffect(() => {
    if ((!currentTabHasPanel || !activeTabId) && isExpanded) {
      updateSetting('sidebarExpanded', false)
    }
  }, [activeTab, currentTabHasPanel, isExpanded, updateSetting, activeTabId])
}
EOF

# Create useLayoutKeyboard.ts
cat > "src/hooks/useLayoutKeyboard.ts" << 'EOF'
import useKeyboardShortcuts from '@/hooks/useKeyboardShortcuts'

interface UseLayoutKeyboardParams {
  onOpenSearch: () => void
}

/**
 * Custom hook for managing layout-specific keyboard shortcuts
 * Encapsulates keyboard interaction logic
 */
export const useLayoutKeyboard = ({ onOpenSearch }: UseLayoutKeyboardParams) => {
  // Initialize keyboard shortcuts
  useKeyboardShortcuts({
    onOpenSearch
  })

  // This hook could be extended in the future to handle additional layout-specific
  // keyboard shortcuts such as:
  // - Tab navigation (Ctrl+Tab, Ctrl+Shift+Tab)
  // - Sidebar toggle (Ctrl+B)
  // - Panel toggle (Ctrl+Shift+E)
  // - Quick settings (Ctrl+,)
}

export default useLayoutKeyboard
EOF

# Create useLayoutServices.ts
cat > "src/hooks/useLayoutServices.ts" << 'EOF'
import { useEffect, useCallback } from 'react'
import { initializeAppService, getAppService } from '@/services/appService'
import { getSearchService } from '@/services/searchService'
import type { Tab } from '@/types/tab'

interface UseLayoutServicesParams {
  addTab: (tab: Tab) => void
  removeTab: (tabId: string) => void
  setActiveTabInHook: (tabId: string) => void
  updateSetting: (key: string, value: any) => void
  success: (title: string, message?: string) => void
  reorderTabs: (newTabs: Tab[]) => void
}

/**
 * Custom hook for managing service initialization and coordination
 * Separates service logic from UI state management
 */
export const useLayoutServices = ({
  addTab,
  removeTab,
  setActiveTabInHook,
  updateSetting,
  success,
  reorderTabs,
}: UseLayoutServicesParams) => {

  // Initialize app service
  useEffect(() => {
    initializeAppService({
      onTabAdd: addTab,
      onTabRemove: removeTab,
      onTabActivate: setActiveTabInHook,
      onSidebarChange: (tabId: string) => updateSetting('activeSidebarTab', tabId),
    })
  }, [addTab, removeTab, setActiveTabInHook, updateSetting])

  // Show welcome notification on app launch
  useEffect(() => {
    const timer = setTimeout(() => {
      success('Welcome to Task Writer!', 'AI-powered development assistant ready to help')
    }, 1000) // Show after 1 second to let the app load

    return () => clearTimeout(timer)
  }, [success])

  // Service-delegated event handlers
  const handleTabChange = useCallback((tabId: string) => {
    const appService = getAppService()
    appService?.changeSidebarItem(tabId)
  }, [])

  const handleTabClick = useCallback((tabId: string) => {
    const appService = getAppService()
    appService?.handleTabClick(tabId)
  }, [])

  const handleTabClose = useCallback((tabId: string) => {
    const appService = getAppService()
    appService?.handleTabClose(tabId)
  }, [])

  const handleTabReorder = useCallback((newTabs: Tab[]) => {
    reorderTabs(newTabs)
  }, [reorderTabs])

  const handleSettingsClick = useCallback(() => {
    const appService = getAppService()
    appService?.openSettings()
  }, [])

  const handleSearchNavigate = useCallback((page: string, section?: string) => {
    const searchService = getSearchService()
    const navigationSuccess = searchService.navigateToResult(page, section)
    
    if (!navigationSuccess) {
      // Handle navigation failure - this shouldn't happen with our search data
      console.warn(`Failed to navigate to ${page}`)
    }
  }, [])

  return {
    handleTabChange,
    handleTabClick,
    handleTabClose,
    handleTabReorder,
    handleSettingsClick,
    handleSearchNavigate,
  }
}
EOF

# Create useLayoutState.ts
cat > "src/hooks/useLayoutState.ts" << 'EOF'
import { useState, useCallback, useMemo } from 'react'
import { useSettings } from '@/hooks/useSettings'
import { useTabs } from '@/hooks/useTabs'
import { useToast } from '@/hooks/useToast'
import { getTabIcon, getPanelComponent } from '@/config/navigationConfig'
import type { Tab } from '@/types/tab'

/**
 * Custom hook for managing layout-specific state and derived values
 * Follows single responsibility principle by handling only layout state
 */
export const useLayoutState = () => {
  // Search modal state
  const [isSearchOpen, setIsSearchOpen] = useState(false)

  // External state hooks
  const {
    settings,
    updateSetting,
    toggleSidebarItemVisibility,
    isSidebarItemVisible,
    toggleSidebarItemPin,
  } = useSettings()
  
  const {
    tabs,
    activeTabId,
    addTab,
    removeTab,
    setActiveTab: setActiveTabInHook,
    reorderTabs,
  } = useTabs()
  
  const { toasts, dismissToast, success } = useToast()

  // Derived state values
  const activeTab = settings.activeSidebarTab
  const isExpanded = settings.sidebarExpanded
  
  // Check if current active tab has a panel
  const currentTabHasPanel = useMemo(
    () => activeTab ? !!getPanelComponent(activeTab) : false,
    [activeTab]
  )

  // Add icons to tabs since they can't be serialized to localStorage
  const tabsWithIcons: Tab[] = useMemo(() => 
    tabs.map((tab) => ({
      ...tab,
      icon: getTabIcon(tab.id),
      closable: tab.closable,
    }))
  , [tabs])

  // Generate CSS classes based on settings
  const cssClasses = useMemo(() => {
    const classes = ['h-screen', 'flex', 'flex-col', 'bg-background', 'text-text']

    // Color scheme class
    classes.push(`color-${settings.colorScheme}`)

    // Theme class
    if (settings.theme === 'dark') {
      classes.push('dark')
    }

    // High contrast class
    if (settings.highContrast) {
      classes.push('high-contrast')
    }

    // Font size class
    classes.push(`font-${settings.fontSize}`)

    // Icon size class
    classes.push(`icon-${settings.iconSize}`)

    // Border thickness class
    classes.push(`border-${settings.borderThickness}`)

    return classes.join(' ')
  }, [settings.theme, settings.highContrast, settings.fontSize, settings.iconSize, settings.borderThickness, settings.colorScheme])

  // Search handlers
  const handleOpenSearch = useCallback(() => {
    setIsSearchOpen(true)
  }, [])

  const handleCloseSearch = useCallback(() => {
    setIsSearchOpen(false)
  }, [])

  // Layout toggle handlers
  const handleToggleSidebarPosition = useCallback(() => {
    updateSetting('sidebarPosition', settings.sidebarPosition === 'left' ? 'right' : 'left')
  }, [updateSetting, settings.sidebarPosition])

  const handleToggleTheme = useCallback(() => {
    updateSetting('theme', settings.theme === 'dark' ? 'light' : 'dark')
  }, [updateSetting, settings.theme])

  const handleToggleExpanded = useCallback(() => {
    updateSetting('sidebarExpanded', !isExpanded)
  }, [updateSetting, isExpanded])

  return {
    // State values
    isSearchOpen,
    settings,
    activeTab,
    isExpanded,
    currentTabHasPanel,
    tabs,
    activeTabId,
    tabsWithIcons,
    toasts,
    cssClasses,

    // State setters and handlers
    handleOpenSearch,
    handleCloseSearch,
    handleToggleSidebarPosition,
    handleToggleTheme,
    handleToggleExpanded,
    updateSetting,
    toggleSidebarItemVisibility,
    isSidebarItemVisible,
    toggleSidebarItemPin,
    dismissToast,
    success,

    // Tab management
    addTab,
    removeTab,
    setActiveTabInHook,
    reorderTabs,
  }
}
EOF

# Create usePlatform.ts
cat > "src/hooks/usePlatform.ts" << 'EOF'
import type { PlatformService } from '../services/platformService'
import { getPlatformService } from '../services/platformService'

export const usePlatform = (): PlatformService => {
  return getPlatformService()
}

export const usePlatformInfo = () => {
  const platformService = getPlatformService()

  return {
    isElectron: platformService.isElectron(),
    isBrowser: platformService.isBrowser(),
    platform: platformService.getPlatform(),
  }
}

EOF

# Create useScaffoldGeneration.ts
cat > "src/hooks/useScaffoldGeneration.ts" << 'EOF'
import { useState, useCallback, useMemo, useEffect } from 'react'
import { ScaffoldGeneratorService } from '@/services/ScaffoldGeneratorService'
import { getPlatformService } from '@/services/platformService'
import { useToast } from '@/hooks/useToast'
import type { TreeNode } from '@/components/ui/FileTree'
import type { QueueItem } from '@/components/ui/QueueList'
import type { 
  ScaffoldSettings, 
  GeneratedScaffold, 
  ScaffoldGenerationStats, 
  ScaffoldGenerationProgress 
} from '@/services/ScaffoldGeneratorService'

/**
 * Custom hook for managing scaffold generation state and operations
 * Follows architecture guide principles:
 * - Single responsibility: Scaffold generation state management
 * - Service integration via dependency injection
 * - Clean separation from UI logic
 */
export const useScaffoldGeneration = () => {
  // State management
  const [selectedPath, setSelectedPath] = useState<string>('')
  const [outputPath, setOutputPath] = useState<string>('')
  const [isLoaded, setIsLoaded] = useState(false)
  const [generating, setGenerating] = useState(false)
  const [progress, setProgress] = useState<ScaffoldGenerationProgress>({ current: 0, total: 0 })
  const [treeData, setTreeData] = useState<TreeNode[]>([])
  const [selectedNode, setSelectedNode] = useState<TreeNode | null>(null)
  const [queueItems, setQueueItems] = useState<QueueItem[]>([])
  const [settings, setSettings] = useState<ScaffoldSettings>(() => {
    // Use service to get default settings
    const service = new ScaffoldGeneratorService(getPlatformService(), { 
      success: () => {}, 
      error: () => {}, 
      warning: () => {} 
    })
    return service.getDefaultSettings()
  })
  const [generatedScaffolds, setGeneratedScaffolds] = useState<GeneratedScaffold[]>([])
  const [previewScaffold, setPreviewScaffold] = useState<GeneratedScaffold | null>(null)
  const [generationStats, setGenerationStats] = useState<ScaffoldGenerationStats>({
    totalScripts: 0,
    completedScripts: 0,
    totalFiles: 0,
    totalDirectories: 0,
  })

  // Service integration
  const toast = useToast()
  const platformService = useMemo(() => getPlatformService(), [])
  const scaffoldGeneratorService = useMemo(() => 
    new ScaffoldGeneratorService(platformService, {
      success: toast.success,
      error: toast.error,
      warning: toast.warning,
    })
  , [platformService, toast])

  // Load persisted paths on mount
  useEffect(() => {
    const loadPersistedPaths = async () => {
      try {
        const settings = await platformService.loadSettings()
        if (settings?.scaffoldPaths) {
          const { selectedPath: savedSelectedPath, outputPath: savedOutputPath } = settings.scaffoldPaths as any
          if (savedSelectedPath) setSelectedPath(savedSelectedPath)
          if (savedOutputPath) setOutputPath(savedOutputPath)
        }
      } catch (error) {
        console.error('Failed to load persisted scaffold paths:', error)
      } finally {
        setIsLoaded(true)
      }
    }
    
    loadPersistedPaths()
  }, [platformService])

  // Persist paths when they change
  useEffect(() => {
    if (!isLoaded) return // Don't persist until initial load is complete
    
    const persistPaths = async () => {
      try {
        const currentSettings = await platformService.loadSettings() || {}
        await platformService.saveSettings({
          ...currentSettings,
          scaffoldPaths: {
            selectedPath,
            outputPath
          }
        })
      } catch (error) {
        console.error('Failed to persist scaffold paths:', error)
      }
    }
    
    persistPaths()
  }, [selectedPath, outputPath, isLoaded, platformService])

  // Directory selection operations
  const selectDirectory = useCallback(async () => {
    const path = await scaffoldGeneratorService.selectDirectory()
    if (path) {
      setSelectedPath(path)
      
      // Auto-scan the directory for preview
      const treeData = await scaffoldGeneratorService.scanDirectory(path)
      if (treeData) {
        setTreeData(treeData)
      }
    }
  }, [scaffoldGeneratorService])

  const selectOutputDirectory = useCallback(async () => {
    const path = await scaffoldGeneratorService.selectOutputDirectory()
    if (path) {
      setOutputPath(path)
    }
  }, [scaffoldGeneratorService])

  // Scaffold generation operations
  const startGeneration = useCallback(async () => {
    // Validate settings
    const validationErrors = scaffoldGeneratorService.validateSettings(settings)
    if (validationErrors.length > 0) {
      toast.error('Invalid settings', validationErrors.join(', '))
      return
    }

    setGenerating(true)
    setProgress({ current: 0, total: 0 })
    setQueueItems([])
    setGeneratedScaffolds([])
    setGenerationStats({ totalScripts: 0, completedScripts: 0, totalFiles: 0, totalDirectories: 0 })

    try {
      const result = await scaffoldGeneratorService.generateScaffolds(
        selectedPath,
        settings,
        setProgress,
        setQueueItems
      )
      
      if (result) {
        setGeneratedScaffolds(result.scaffolds)
        setGenerationStats(result.stats)
      }
    } finally {
      setGenerating(false)
    }
  }, [selectedPath, settings, scaffoldGeneratorService, toast])

  // Export operations
  const exportScaffolds = useCallback(async () => {
    const result = await scaffoldGeneratorService.exportScaffolds(generatedScaffolds)
    if (result?.directory) {
      setOutputPath(result.directory)
    }
  }, [generatedScaffolds, scaffoldGeneratorService])

  const exportSingleScaffold = useCallback(async (scaffold: GeneratedScaffold) => {
    await scaffoldGeneratorService.exportSingleScaffold(scaffold)
  }, [scaffoldGeneratorService])

  // Settings management
  const updateSettings = useCallback((newSettings: Partial<ScaffoldSettings>) => {
    setSettings(prev => {
      const updated = { ...prev, ...newSettings }
      
      // Auto-update output format when target OS changes
      if (newSettings.targetOS && newSettings.targetOS !== prev.targetOS) {
        const supportedFormats = scaffoldGeneratorService.getSupportedFormats(newSettings.targetOS)
        if (!supportedFormats.includes(updated.outputFormat)) {
          updated.outputFormat = scaffoldGeneratorService.getDefaultFormat(newSettings.targetOS)
        }
      }
      
      return updated
    })
  }, [scaffoldGeneratorService])

  const resetSettings = useCallback(() => {
    setSettings(scaffoldGeneratorService.getDefaultSettings())
  }, [scaffoldGeneratorService])

  // Template variable management
  const addTemplateVariable = useCallback((key: string, value: string) => {
    setSettings(prev => ({
      ...prev,
      templateVariables: {
        ...prev.templateVariables,
        [key]: value
      }
    }))
  }, [])

  const removeTemplateVariable = useCallback((key: string) => {
    setSettings(prev => {
      const newVars = { ...prev.templateVariables }
      delete newVars[key]
      return {
        ...prev,
        templateVariables: newVars
      }
    })
  }, [])

  // File type management
  const addFileType = useCallback((fileType: string) => {
    if (!fileType.startsWith('.')) {
      fileType = '.' + fileType
    }
    
    setSettings(prev => ({
      ...prev,
      supportedFileTypes: [...new Set([...prev.supportedFileTypes, fileType])]
    }))
  }, [])

  const removeFileType = useCallback((fileType: string) => {
    setSettings(prev => ({
      ...prev,
      supportedFileTypes: prev.supportedFileTypes.filter(type => type !== fileType)
    }))
  }, [])

  // Preview management
  const setScaffoldPreview = useCallback((scaffold: GeneratedScaffold | null) => {
    setPreviewScaffold(scaffold)
  }, [])

  // Tree node selection
  const selectTreeNode = useCallback((node: TreeNode | null) => {
    setSelectedNode(node)
  }, [])

  // Clear paths only
  const clearPaths = useCallback(() => {
    setSelectedPath('')
    setOutputPath('')
    setTreeData([])
    setSelectedNode(null)
  }, [])

  // Reset state
  const resetState = useCallback(() => {
    setSelectedPath('')
    setOutputPath('')
    setGenerating(false)
    setProgress({ current: 0, total: 0 })
    setTreeData([])
    setSelectedNode(null)
    setQueueItems([])
    setGeneratedScaffolds([])
    setPreviewScaffold(null)
    setGenerationStats({ totalScripts: 0, completedScripts: 0, totalFiles: 0, totalDirectories: 0 })
  }, [])

  // Computed values
  const hasSelectedDirectory = selectedPath.length > 0
  const hasGeneratedScaffolds = generatedScaffolds.length > 0
  const canGenerate = hasSelectedDirectory && !generating
  const canExport = hasGeneratedScaffolds && !generating
  const supportedFormats = useMemo(() => 
    scaffoldGeneratorService.getSupportedFormats(settings.targetOS)
  , [scaffoldGeneratorService, settings.targetOS])

  return {
    // State values
    selectedPath,
    outputPath,
    generating,
    progress,
    treeData,
    selectedNode,
    queueItems,
    settings,
    generatedScaffolds,
    previewScaffold,
    generationStats,

    // Computed values
    hasSelectedDirectory,
    hasGeneratedScaffolds,
    canGenerate,
    canExport,
    supportedFormats,

    // Operations
    selectDirectory,
    selectOutputDirectory,
    startGeneration,
    exportScaffolds,
    exportSingleScaffold,
    updateSettings,
    resetSettings,
    addTemplateVariable,
    removeTemplateVariable,
    addFileType,
    removeFileType,
    setScaffoldPreview,
    selectTreeNode,
    clearPaths,
    resetState,
  }
}
EOF

# Create useSettings.ts
cat > "src/hooks/useSettings.ts" << 'EOF'
import { useState, useEffect } from 'react'
import { getPlatformService } from '@/services/platformService'

export type ColorScheme = 
  | 'onyx' 
  | 'ocean-blue' 
  | 'forest-green' 
  | 'royal-purple' 
  | 'sunset-orange' 
  | 'cyberpunk' 
  | 'office' 
  | 'terminal' 
  | 'midnight-blue' 
  | 'crimson-red' 
  | 'warm-sepia' 
  | 'rose-gold'

export interface AppSettings {
  theme: 'dark' | 'light'                    // Mode dimension
  colorScheme: ColorScheme                   // NEW: Color scheme dimension  
  sidebarPosition: 'left' | 'right'
  showStatusBar: boolean
  fontSize: 'small' | 'medium' | 'large'
  iconSize: 'small' | 'medium' | 'large'
  highContrast: boolean
  borderThickness: 'none' | 'thin' | 'medium' | 'thick'
  sidebarExpanded: boolean
  activeSidebarTab: string // ID of the currently active/selected sidebar navigation item
  sidebarItemVisibility: Record<string, boolean> // Stores user overrides for sidebar item visibility
  pinnedSidebarItems: string[] // Stores IDs of sidebar items pinned by the user
  [key: string]: unknown // Allows for additional, untyped settings
}

const defaultSettings: AppSettings = {
  theme: 'dark',
  colorScheme: 'onyx',                      // NEW: Default to onyx scheme for backward compatibility
  sidebarPosition: 'left',
  showStatusBar: true,
  fontSize: 'small',
  iconSize: 'small',
  highContrast: false,
  borderThickness: 'medium',
  sidebarExpanded: true,
  activeSidebarTab: '',
  sidebarItemVisibility: {},
  pinnedSidebarItems: [],
}

export const useSettings = () => {
  const [settings, setSettings] = useState<AppSettings>(defaultSettings)
  const [isLoaded, setIsLoaded] = useState(false)
  const platformService = getPlatformService()

  useEffect(() => {
    const loadSettings = async () => {
      try {
        const stored = await platformService.loadSettings()
        if (stored) {
          // Migration: Ensure colorScheme exists for existing users (backward compatibility)
          const mergedSettings = { 
            ...defaultSettings, 
            ...stored,
            colorScheme: (stored.colorScheme as ColorScheme) || 'onyx'
          }
          setSettings(mergedSettings)
        }
      } catch (error) {
        console.error('Failed to load settings via platform service:', error)
      } finally {
        setIsLoaded(true)
      }
    }

    loadSettings()
  }, [platformService])

  // Save settings whenever they change (but only after initial load)
  useEffect(() => {
    if (isLoaded) {
      const saveSettings = async () => {
        try {
          await platformService.saveSettings(settings)
        } catch (error) {
          console.error('Failed to save settings via platform service:', error)
        }
      }
      saveSettings()
    }
  }, [settings, isLoaded, platformService])

  const updateSetting = <K extends keyof AppSettings>(key: K, value: AppSettings[K]) => {
    setSettings((prev) => ({
      ...prev,
      [key]: value,
    }))
  }

  // Helper functions for sidebar item visibility management
  const setSidebarItemVisibility = (itemId: string, visible: boolean) => {
    const newVisibility = { ...settings.sidebarItemVisibility }
    newVisibility[itemId] = visible
    updateSetting('sidebarItemVisibility', newVisibility)
  }

  const toggleSidebarItemVisibility = (itemId: string, defaultVisible: boolean = true) => {
    const currentlyVisible = settings.sidebarItemVisibility[itemId] ?? defaultVisible
    setSidebarItemVisibility(itemId, !currentlyVisible)
  }

  const isSidebarItemVisible = (itemId: string, defaultVisible: boolean = true) => {
    return settings.sidebarItemVisibility[itemId] ?? defaultVisible
  }

  const toggleSidebarItemPin = (itemId: string) => {
    const pinnedItems = [...settings.pinnedSidebarItems]
    const index = pinnedItems.indexOf(itemId)
    if (index > -1) {
      pinnedItems.splice(index, 1)
    } else {
      pinnedItems.push(itemId)
    }
    updateSetting('pinnedSidebarItems', pinnedItems)
  }

  return {
    settings,
    updateSetting,
    setSidebarItemVisibility,
    toggleSidebarItemVisibility,
    isSidebarItemVisible,
    toggleSidebarItemPin,
    isLoaded, // Added isLoaded to the return
  }
}

EOF

# Create useSidebarManagement.ts
cat > "src/hooks/useSidebarManagement.ts" << 'EOF'
import { useMemo } from 'react'
import { getSidebarItems, getSidebarIcon } from '@/config/navigationConfig'
import type { NavigationItem } from '@/types/navigation'

export interface SidebarItem {
  id: string
  label: string
  icon: React.ReactElement | null
  visible: boolean
  pinned: boolean
  showInSidebar: boolean
}

interface UseSidebarManagementParams {
  isSidebarItemVisible: (itemId: string, defaultVisible: boolean) => boolean
  pinnedSidebarItems: string[]
  onToggleVisibility: (itemId: string) => void
  onTogglePin: (itemId: string) => void
}

/**
 * Custom hook for managing sidebar items state and operations
 * Follows architecture guide principles:
 * - Single responsibility: Sidebar management logic
 * - Clean separation from UI
 * - Computed values with proper memoization
 */
export const useSidebarManagement = ({
  isSidebarItemVisible,
  pinnedSidebarItems,
  onToggleVisibility,
  onTogglePin,
}: UseSidebarManagementParams) => {
  
  // Get only sidebar-enabled navigation items and transform for sidebar management
  const sidebarItems = useMemo(() => {
    const sidebarOnlyItems = getSidebarItems()
    
    return sidebarOnlyItems.map((item: NavigationItem): SidebarItem => {
      const visible = isSidebarItemVisible(item.id, item.showInSidebar)
      const pinned = pinnedSidebarItems.includes(item.id)
      
      return {
        id: item.id,
        label: item.label,
        icon: getSidebarIcon(item.id),
        visible,
        pinned,
        showInSidebar: item.showInSidebar,
      }
    })
  }, [isSidebarItemVisible, pinnedSidebarItems])

  // Separate items by their current state
  const visibleItems = useMemo(() => 
    sidebarItems.filter(item => item.visible)
  , [sidebarItems])

  const hiddenItems = useMemo(() => 
    sidebarItems.filter(item => !item.visible)
  , [sidebarItems])

  const pinnedItems = useMemo(() => 
    sidebarItems.filter(item => item.pinned)
  , [sidebarItems])

  const unpinnedItems = useMemo(() => 
    sidebarItems.filter(item => !item.pinned && item.visible)
  , [sidebarItems])

  // Statistics
  const stats = useMemo(() => ({
    total: sidebarItems.length,
    visible: visibleItems.length,
    hidden: hiddenItems.length,
    pinned: pinnedItems.length,
  }), [sidebarItems.length, visibleItems.length, hiddenItems.length, pinnedItems.length])

  return {
    // Data
    sidebarItems,
    visibleItems,
    hiddenItems,
    pinnedItems,
    unpinnedItems,
    stats,
    
    // Actions
    onToggleVisibility,
    onTogglePin,
  }
}
EOF

# Create useSpotlightKeyboard.ts
cat > "src/hooks/useSpotlightKeyboard.ts" << 'EOF'
import { useCallback } from 'react'
import type { SearchResult } from '@/data/searchData'

interface UseSpotlightKeyboardParams {
  results: SearchResult[]
  selectedIndex: number
  setSelectedIndex: (index: number) => void
  onClose: () => void
  onSelect: (result: SearchResult) => void
}

/**
 * Custom hook for managing spotlight search keyboard navigation
 * Follows architecture guide principles:
 * - Single responsibility: Keyboard interaction logic
 * - Clean separation from UI logic
 * - Reusable across search components
 */
export const useSpotlightKeyboard = ({
  results,
  selectedIndex,
  setSelectedIndex,
  onClose,
  onSelect,
}: UseSpotlightKeyboardParams) => {

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    switch (event.key) {
      case 'Escape':
        event.preventDefault()
        onClose()
        break
        
      case 'ArrowDown':
        event.preventDefault()
        if (results.length > 0) {
          setSelectedIndex((selectedIndex + 1) % results.length)
        }
        break
        
      case 'ArrowUp':
        event.preventDefault()
        if (results.length > 0) {
          setSelectedIndex(selectedIndex === 0 ? results.length - 1 : selectedIndex - 1)
        }
        break
        
      case 'Enter':
        event.preventDefault()
        if (results.length > 0 && selectedIndex < results.length) {
          onSelect(results[selectedIndex])
        }
        break
        
      case 'Home':
        event.preventDefault()
        if (results.length > 0) {
          setSelectedIndex(0)
        }
        break
        
      case 'End':
        event.preventDefault()
        if (results.length > 0) {
          setSelectedIndex(results.length - 1)
        }
        break
    }
  }, [results, selectedIndex, setSelectedIndex, onClose, onSelect])

  return {
    handleKeyDown,
  }
}

export default useSpotlightKeyboard
EOF

# Create useSpotlightSearch.ts
cat > "src/hooks/useSpotlightSearch.ts" << 'EOF'
import { useState, useEffect, useCallback, useRef } from 'react'
import { searchResults, type SearchResult } from '@/data/searchData'

interface UseSpotlightSearchParams {
  isOpen: boolean
  onNavigate: (page: string, section?: string) => void
  onClose: () => void
}

/**
 * Custom hook for managing spotlight search state and operations
 * Follows architecture guide principles:
 * - Single responsibility: Search state management
 * - Clean separation from UI logic
 * - Reusable search functionality
 */
export const useSpotlightSearch = ({
  isOpen,
  onNavigate,
  onClose,
}: UseSpotlightSearchParams) => {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [selectedIndex, setSelectedIndex] = useState(0)
  const inputRef = useRef<HTMLInputElement>(null)

  // Clear state when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setQuery('')
      setResults([])
      setSelectedIndex(0)
      // Focus input after animation
      setTimeout(() => inputRef.current?.focus(), 150)
    }
  }, [isOpen])

  // Handle search query changes
  useEffect(() => {
    if (query.trim()) {
      const searchResultsData = searchResults(query, 6) // Limit to 6 results for compact view
      setResults(searchResultsData)
      setSelectedIndex(0)
    } else {
      setResults([])
      setSelectedIndex(0)
    }
  }, [query])

  // Handle result selection
  const handleSelect = useCallback((result: SearchResult) => {
    onNavigate(result.page, result.section)
    onClose()
  }, [onNavigate, onClose])

  // Handle query changes
  const handleQueryChange = useCallback((newQuery: string) => {
    setQuery(newQuery)
  }, [])

  return {
    // State
    query,
    results,
    selectedIndex,
    inputRef,

    // Actions
    setSelectedIndex,
    handleSelect,
    handleQueryChange,
  }
}
EOF

# Create useTabBarDragDrop.ts
cat > "src/hooks/useTabBarDragDrop.ts" << 'EOF'
import { useState, useCallback } from 'react'
import {
  PointerSensor,
  KeyboardSensor,
  useSensor,
  useSensors,
  type DragStartEvent,
  type DragEndEvent,
} from '@dnd-kit/core'
import { arrayMove } from '@dnd-kit/sortable'
import type { Tab } from '@/types/tab'

interface UseTabBarDragDropParams {
  tabs: Tab[]
  onTabReorder?: (reorderedTabs: Tab[]) => void
}

/**
 * Custom hook for managing TabBar drag and drop functionality
 * Follows architecture guide principles:
 * - Single responsibility: Drag & drop state management
 * - Clean separation from UI logic
 * - Encapsulates complex dnd-kit integration
 */
export const useTabBarDragDrop = ({
  tabs,
  onTabReorder,
}: UseTabBarDragDropParams) => {
  const [activeTab, setActiveTab] = useState<Tab | null>(null)

  // Configure sensors for drag & drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor)
  )

  const handleDragStart = useCallback((event: DragStartEvent) => {
    const { active } = event
    const activeTabData = tabs.find(tab => tab.id === active.id)
    setActiveTab(activeTabData || null)
  }, [tabs])

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event

    if (active.id !== over?.id) {
      const oldIndex = tabs.findIndex(tab => tab.id === active.id)
      const newIndex = tabs.findIndex(tab => tab.id === over?.id)

      if (oldIndex !== -1 && newIndex !== -1) {
        const reorderedTabs = arrayMove(tabs, oldIndex, newIndex)
        onTabReorder?.(reorderedTabs)
      }
    }

    setActiveTab(null)
  }, [tabs, onTabReorder])

  const handleDragCancel = useCallback(() => {
    setActiveTab(null)
  }, [])

  return {
    // State
    activeTab,
    
    // Sensors and handlers
    sensors,
    handleDragStart,
    handleDragEnd,
    handleDragCancel,
    
    // Derived state
    isDragging: !!activeTab,
  }
}
EOF

# Create useTabBarScroll.ts
cat > "src/hooks/useTabBarScroll.ts" << 'EOF'
import { useState, useRef, useEffect, useCallback } from 'react'

/**
 * Custom hook for managing TabBar horizontal scrolling
 * Follows architecture guide principles:
 * - Single responsibility: Scroll state management
 * - Clean separation from UI logic
 * - Reusable scroll functionality
 */
export const useTabBarScroll = () => {
  const [canScrollLeft, setCanScrollLeft] = useState(false)
  const [canScrollRight, setCanScrollRight] = useState(false)
  const scrollContainerRef = useRef<HTMLDivElement>(null)

  // Check scroll position and update button states
  const updateScrollButtons = useCallback(() => {
    const container = scrollContainerRef.current
    if (!container) return

    const { scrollLeft, scrollWidth, clientWidth } = container
    
    setCanScrollLeft(scrollLeft > 0)
    setCanScrollRight(scrollLeft < scrollWidth - clientWidth - 1) // -1 for rounding
  }, [])

  // Scroll functions
  const scrollLeft = useCallback(() => {
    const container = scrollContainerRef.current
    if (!container) return

    const scrollAmount = container.clientWidth * 0.8 // Scroll 80% of visible width
    container.scrollBy({
      left: -scrollAmount,
      behavior: 'smooth'
    })
  }, [])

  const scrollRight = useCallback(() => {
    const container = scrollContainerRef.current
    if (!container) return

    const scrollAmount = container.clientWidth * 0.8 // Scroll 80% of visible width
    container.scrollBy({
      left: scrollAmount,
      behavior: 'smooth'
    })
  }, [])

  // Update scroll buttons when container size or content changes
  useEffect(() => {
    const container = scrollContainerRef.current
    if (!container) return

    // Initial check
    updateScrollButtons()

    // Listen for scroll events
    container.addEventListener('scroll', updateScrollButtons)
    
    // Listen for resize events
    const resizeObserver = new ResizeObserver(updateScrollButtons)
    resizeObserver.observe(container)

    return () => {
      container.removeEventListener('scroll', updateScrollButtons)
      resizeObserver.disconnect()
    }
  }, [updateScrollButtons])

  return {
    // Refs
    scrollContainerRef,
    
    // State
    canScrollLeft,
    canScrollRight,
    
    // Actions
    scrollLeft,
    scrollRight,
    updateScrollButtons,
  }
}
EOF

# Create useTabs.ts
cat > "src/hooks/useTabs.ts" << 'EOF'
import { useState, useEffect, useCallback } from 'react'
import type { Tab } from '../types/tab' // Using the Tab type from types folder

const STORAGE_KEY_PREFIX = 'app' // App-specific prefix
const TABS_STORAGE_KEY = `${STORAGE_KEY_PREFIX}-tabs`

// Helper to strip non-serializable parts (like icons) for storage
const sanitizeTabsForStorage = (tabs: Tab[]): Omit<Tab, 'icon'>[] => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return tabs.map(({ icon, ...rest }) => rest)
}

export const useTabs = () => {
  const [tabs, setTabs] = useState<Tab[]>([])
  const [activeTabId, setActiveTabId] = useState<string | null>(null)
  const [isTabsLoaded, setIsTabsLoaded] = useState(false)

  // Load tabs from localStorage on initial mount
  useEffect(() => {
    try {
      const storedTabsData = localStorage.getItem(TABS_STORAGE_KEY)
      if (storedTabsData) {
        const { tabs: storedSanitizedTabs, activeTabId: storedActiveTabId } = JSON.parse(
          storedTabsData,
        ) as { tabs: Omit<Tab, 'icon'>[]; activeTabId: string | null }

        // Restore tabs without icons; icons will be added by Layout/navigationConfig
        const restoredTabs = storedSanitizedTabs.map((tab) => ({
          ...tab,
          icon: undefined, // Icons are not stored
          closable: tab.closable ?? true, // Ensure closable property is set for restored tabs
        }))

        setTabs(restoredTabs)
        setActiveTabId(storedActiveTabId)
      }
    } catch (error) {
      console.error('useTabs: Failed to load tabs from localStorage, initializing empty.', error)
      setTabs([])
      setActiveTabId(null)
    } finally {
      setIsTabsLoaded(true)
    }
  }, [])

  // Save tabs to localStorage whenever they change (and after initial load)
  useEffect(() => {
    if (isTabsLoaded) {
      try {
        if (tabs.length > 0 || activeTabId !== null) {
          const dataToStore = {
            tabs: sanitizeTabsForStorage(tabs),
            activeTabId,
          }
          localStorage.setItem(TABS_STORAGE_KEY, JSON.stringify(dataToStore))
        } else {
          localStorage.removeItem(TABS_STORAGE_KEY) // Clean up if no tabs
        }
      } catch (error) {
        console.error('useTabs: Failed to save tabs to localStorage.', error)
      }
    }
  }, [tabs, activeTabId, isTabsLoaded])

  const addTab = useCallback(
    (newTabInfo: Omit<Tab, 'isActive' | 'icon'> & { icon?: React.ReactNode }) => {
      setTabs((prevTabs) => {
        const existingTab = prevTabs.find((t) => t.id === newTabInfo.id)
        if (existingTab) {
          // If tab exists, just make it active
          setActiveTabId(existingTab.id)
          return prevTabs.map((t) => ({ ...t, isActive: t.id === existingTab.id }))
        }
        // Add new tab and make it active
        const fullNewTab: Tab = {
          ...newTabInfo,
          isActive: true,
          closable: newTabInfo.closable ?? true, // Ensure closable property is set
        }
        setActiveTabId(fullNewTab.id)
        return [...prevTabs.map((t) => ({ ...t, isActive: false })), fullNewTab]
      })
    },
    [],
  )

  const removeTab = useCallback(
    (tabIdToRemove: string) => {
      setTabs((prevTabs) => {
        // Check if tab exists in the current state
        const tabExists = prevTabs.some(t => t.id === tabIdToRemove)
        
        if (!tabExists) {
          return prevTabs // Tab doesn't exist, no change needed
        }

        // Find the currently active tab from the prevTabs array
        const currentActiveTab = prevTabs.find(t => t.isActive)
        const currentActiveTabId = currentActiveTab?.id || null
        
        const isRemovingActiveTab = currentActiveTabId === tabIdToRemove
        const newTabs = prevTabs.filter((t) => t.id !== tabIdToRemove)
        
        // Calculate new active tab if we're removing the active one
        if (isRemovingActiveTab && newTabs.length > 0) {
          // Find the index of the tab being removed in the original array
          const removedTabIndex = prevTabs.findIndex(t => t.id === tabIdToRemove)
          
          let newActiveTabId: string | null = null
          
          // Try to activate the tab to the right (same index after removal)
          if (removedTabIndex < newTabs.length) {
            newActiveTabId = newTabs[removedTabIndex].id
          }
          // If no tab to the right, activate the tab to the left (previous index)
          else if (removedTabIndex > 0) {
            newActiveTabId = newTabs[removedTabIndex - 1].id
          }
          // Fallback to first tab
          else {
            newActiveTabId = newTabs[0].id
          }
          
          // Update activeTabId state
          setActiveTabId(newActiveTabId)
          
          // Return new tabs with correct isActive state
          return newTabs.map((t) => ({ ...t, isActive: t.id === newActiveTabId }))
        } else if (isRemovingActiveTab && newTabs.length === 0) {
          setActiveTabId(null)
          return newTabs
        } else {
          // Just remove the tab, keep the same active tab
          return newTabs.map((t) => ({ ...t, isActive: t.id === currentActiveTabId }))
        }
      })
    },
    [],
  )

  const setActiveTab = useCallback((tabIdToActivate: string) => {
    setTabs((prevTabs) => prevTabs.map((t) => ({ ...t, isActive: t.id === tabIdToActivate })))
    setActiveTabId(tabIdToActivate)
  }, [])

  const reorderTabs = useCallback((newOrderedTabs: Tab[]) => {
    // Assumes newOrderedTabs contains all current tabs, just in a new order.
    // The activeTabId should remain the same unless explicitly changed.
    // The isActive property within newOrderedTabs should reflect the current active tab.
    setTabs(newOrderedTabs)
  }, [])

  return {
    tabs,
    activeTabId,
    addTab,
    removeTab,
    setActiveTab,
    reorderTabs,
    isTabsLoaded, // Expose loading state if needed
  }
}

EOF

# Create useTaskGeneration.ts
cat > "src/hooks/useTaskGeneration.ts" << 'EOF'
import { useState, useCallback, useMemo } from 'react'
import { TaskGeneratorService } from '@/services/TaskGeneratorService'
import { getPlatformService } from '@/services/platformService'
import { useToast } from '@/hooks/useToast'
import type { TreeNode } from '@/components/ui/FileTree'
import type { QueueItem } from '@/components/ui/QueueList'
import type { 
  TaskSettings, 
  GeneratedTask, 
  GenerationStats, 
  GenerationProgress 
} from '@/services/TaskGeneratorService'

/**
 * Custom hook for managing task generation state and operations
 * Follows architecture guide principles:
 * - Single responsibility: Task generation state management
 * - Service integration via dependency injection
 * - Clean separation from UI logic
 */
export const useTaskGeneration = () => {
  // State management
  const [selectedPath, setSelectedPath] = useState<string>('')
  const [outputPath, setOutputPath] = useState<string>('')
  const [generating, setGenerating] = useState(false)
  const [progress, setProgress] = useState<GenerationProgress>({ current: 0, total: 0 })
  const [treeData, setTreeData] = useState<TreeNode[]>([])
  const [selectedNode, setSelectedNode] = useState<TreeNode | null>(null)
  const [queueItems, setQueueItems] = useState<QueueItem[]>([])
  const [settings, setSettings] = useState<TaskSettings>(() => {
    // Use service to get default settings
    const platformService = getPlatformService()
    const service = new TaskGeneratorService(platformService, { 
      success: () => {}, 
      error: () => {}, 
      warning: () => {} 
    })
    return service.getDefaultSettings()
  })
  const [generatedTasks, setGeneratedTasks] = useState<GeneratedTask[]>([])
  const [previewTask, setPreviewTask] = useState<GeneratedTask | null>(null)
  const [generationStats, setGenerationStats] = useState<GenerationStats>({
    totalTasks: 0,
    completedTasks: 0,
    totalFiles: 0,
    processedFiles: 0,
  })

  // Service integration
  const toast = useToast()
  const platformService = getPlatformService()
  const taskGeneratorService = useMemo(() => 
    new TaskGeneratorService(platformService, {
      success: toast.success,
      error: toast.error,
      warning: toast.warning,
    })
  , [toast, platformService])

  // Directory selection operations
  const selectDirectory = useCallback(async () => {
    const path = await taskGeneratorService.selectDirectory()
    if (path) {
      setSelectedPath(path)
      
      // Auto-scan the directory for preview
      const treeData = await taskGeneratorService.scanDirectory(path)
      if (treeData) {
        setTreeData(treeData)
      }
    }
  }, [taskGeneratorService])

  const selectOutputDirectory = useCallback(async () => {
    const path = await taskGeneratorService.selectOutputDirectory()
    if (path) {
      setOutputPath(path)
    }
  }, [taskGeneratorService])

  // Task generation operations
  const startGeneration = useCallback(async () => {
    // Validate settings
    const validationErrors = taskGeneratorService.validateSettings(settings)
    if (validationErrors.length > 0) {
      toast.error('Invalid settings', validationErrors.join(', '))
      return
    }

    setGenerating(true)
    setProgress({ current: 0, total: 0 })
    setQueueItems([])
    setGeneratedTasks([])
    setGenerationStats({ totalTasks: 0, completedTasks: 0, totalFiles: 0, processedFiles: 0 })

    try {
      const result = await taskGeneratorService.generateTasks(
        selectedPath,
        settings,
        setProgress,
        setQueueItems
      )
      
      if (result) {
        setGeneratedTasks(result.tasks)
        setGenerationStats(result.stats)
      }
    } finally {
      setGenerating(false)
    }
  }, [selectedPath, settings, taskGeneratorService, toast])

  // Export operations
  const exportTasks = useCallback(async () => {
    const result = await taskGeneratorService.exportTasks(generatedTasks, settings.outputFormat)
    if (result?.directory) {
      setOutputPath(result.directory)
    }
  }, [generatedTasks, settings.outputFormat, taskGeneratorService])

  const exportSingleTask = useCallback(async (task: GeneratedTask) => {
    await taskGeneratorService.exportSingleTask(task)
  }, [taskGeneratorService])

  // Settings management
  const updateSettings = useCallback((newSettings: Partial<TaskSettings>) => {
    setSettings(prev => ({ ...prev, ...newSettings }))
  }, [])

  const resetSettings = useCallback(() => {
    setSettings(taskGeneratorService.getDefaultSettings())
  }, [taskGeneratorService])

  // Preview management
  const setTaskPreview = useCallback((task: GeneratedTask | null) => {
    setPreviewTask(task)
  }, [])

  // Tree node selection
  const selectTreeNode = useCallback((node: TreeNode | null) => {
    setSelectedNode(node)
  }, [])

  // Reset state
  const resetState = useCallback(() => {
    setSelectedPath('')
    setOutputPath('')
    setGenerating(false)
    setProgress({ current: 0, total: 0 })
    setTreeData([])
    setSelectedNode(null)
    setQueueItems([])
    setGeneratedTasks([])
    setPreviewTask(null)
    setGenerationStats({ totalTasks: 0, completedTasks: 0, totalFiles: 0, processedFiles: 0 })
  }, [])

  // Computed values
  const hasSelectedDirectory = selectedPath.length > 0
  const hasGeneratedTasks = generatedTasks.length > 0
  const canGenerate = hasSelectedDirectory && !generating
  const canExport = hasGeneratedTasks && !generating

  return {
    // State values
    selectedPath,
    outputPath,
    generating,
    progress,
    treeData,
    selectedNode,
    queueItems,
    settings,
    generatedTasks,
    previewTask,
    generationStats,

    // Computed values
    hasSelectedDirectory,
    hasGeneratedTasks,
    canGenerate,
    canExport,

    // Operations
    selectDirectory,
    selectOutputDirectory,
    startGeneration,
    exportTasks,
    exportSingleTask,
    updateSettings,
    resetSettings,
    setTaskPreview,
    selectTreeNode,
    resetState,
  }
}
EOF

# Create useToast.ts
cat > "src/hooks/useToast.ts" << 'EOF'
import { useState, useCallback } from 'react'
import type { Toast } from '../components/ui/Toast'

interface UseToastReturn {
  toasts: Toast[]
  showToast: (toast: Omit<Toast, 'id'>) => void
  dismissToast: (id: string) => void
  clearAllToasts: () => void
  success: (title: string, message?: string) => void
  error: (title: string, message?: string) => void
  warning: (title: string, message?: string) => void
  info: (title: string, message?: string) => void
}

export const useToast = (): UseToastReturn => {
  const [toasts, setToasts] = useState<Toast[]>([])

  const showToast = useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9)
    const newToast: Toast = {
      ...toast,
      id,
      duration: toast.duration ?? 5000, // Default 5 seconds
    }
    
    setToasts(prev => [...prev, newToast])
  }, [])

  const dismissToast = useCallback((id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id))
  }, [])

  const clearAllToasts = useCallback(() => {
    setToasts([])
  }, [])

  // Helper methods for different toast types
  const success = useCallback((title: string, message?: string) => {
    showToast({ type: 'success', title, message })
  }, [showToast])

  const error = useCallback((title: string, message?: string) => {
    showToast({ type: 'error', title, message, duration: 7000 })
  }, [showToast])

  const warning = useCallback((title: string, message?: string) => {
    showToast({ type: 'warning', title, message })
  }, [showToast])

  const info = useCallback((title: string, message?: string) => {
    showToast({ type: 'info', title, message })
  }, [showToast])

  return {
    toasts,
    showToast,
    dismissToast,
    clearAllToasts,
    success,
    error,
    warning,
    info,
  }
}
EOF

# Create useWelcomeAnimations.ts
cat > "src/hooks/useWelcomeAnimations.ts" << 'EOF'
import { useReducedMotion } from 'framer-motion'

/**
 * Custom hook for managing Welcome page animations
 * Follows architecture guide principles:
 * - Single responsibility: Animation configuration and variants
 * - Clean separation from UI logic
 * - Responsive to accessibility preferences
 */
export const useWelcomeAnimations = () => {
  const prefersReducedMotion = useReducedMotion() ?? false

  // Animation variants for reduced motion support
  const createAnimationVariants = (customDuration?: number) => ({
    initial: prefersReducedMotion ? {} : { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0 },
    transition: prefersReducedMotion ? { duration: 0 } : { 
      duration: customDuration || 0.4,
      ease: "easeOut"
    }
  })

  // Staggered animation for cards container
  const containerVariants = {
    hidden: { opacity: prefersReducedMotion ? 1 : 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: prefersReducedMotion ? 0 : 0.2,
        delayChildren: prefersReducedMotion ? 0 : 0.1
      }
    }
  }

  // Individual card animation variants
  const cardVariants = {
    hidden: { 
      opacity: prefersReducedMotion ? 1 : 0, 
      y: prefersReducedMotion ? 0 : 30 
    },
    visible: { 
      opacity: 1, 
      y: 0,
      transition: { 
        duration: prefersReducedMotion ? 0 : 0.5, 
        ease: "easeOut" 
      }
    }
  }

  // CSS classes for motion-safe animations
  const getMotionClasses = (baseClasses: string, motionClasses: string) => {
    return prefersReducedMotion ? baseClasses : `${baseClasses} ${motionClasses}`
  }

  // Header animation with custom duration
  const headerVariants = createAnimationVariants(0.6)

  return {
    prefersReducedMotion,
    createAnimationVariants,
    containerVariants,
    cardVariants,
    headerVariants,
    getMotionClasses,
  }
}
EOF

# Create useWelcomeState.ts
cat > "src/hooks/useWelcomeState.ts" << 'EOF'
import { useState, useEffect, useCallback } from 'react'
import { useToast } from '@/hooks/useToast'
import { getAppService } from '@/services/appService'

/**
 * Custom hook for managing Welcome page state and interactions
 * Follows architecture guide principles:
 * - Single responsibility: Welcome page state management
 * - Clean separation from UI logic
 * - Reusable interaction handlers
 */
export const useWelcomeState = () => {
  const toast = useToast()
  const appService = getAppService()
  
  // State for keyboard navigation
  const [focusedCardIndex, setFocusedCardIndex] = useState<number | null>(null)
  
  // Announcement for screen readers
  const [announcement, setAnnouncement] = useState('')

  const handleOpenTab = useCallback((tabId: string, tabName: string) => {
    try {
      if (!appService) {
        const errorMessage = 'App service not available. Please refresh the page.'
        toast.error('Application Error', errorMessage)
        setAnnouncement(`Error: ${errorMessage}`)
        return
      }
      
      const success = appService.openTab(tabId)
      if (!success) {
        const errorMessage = `Could not open ${tabName}. Please try again.`
        toast.error('Failed to open tab', errorMessage)
        setAnnouncement(`Error: ${errorMessage}`)
      } else {
        setAnnouncement(`Opening ${tabName}`)
      }
    } catch (error) {
      console.error('Error opening tab:', error)
      const errorMessage = `Failed to open ${tabName} due to an unexpected error.`
      toast.error('Unexpected Error', errorMessage)
      setAnnouncement(`Error: ${errorMessage}`)
    }
  }, [appService, toast])

  // Keyboard navigation handler
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Escape') {
      setFocusedCardIndex(null)
    }
  }, [])

  // Focus management
  const handleFocus = useCallback((index: number) => {
    setFocusedCardIndex(index)
  }, [])

  const handleBlur = useCallback(() => {
    setFocusedCardIndex(null)
  }, [])

  // Clear announcements after they're read
  useEffect(() => {
    if (announcement) {
      const timer = setTimeout(() => setAnnouncement(''), 3000)
      return () => clearTimeout(timer)
    }
  }, [announcement])

  return {
    focusedCardIndex,
    announcement,
    handleOpenTab,
    handleKeyDown,
    handleFocus,
    handleBlur,
  }
}
EOF


# Scaffold generation completed
echo "Scaffold generation completed successfully!"#!/bin/bash

#============================================================================
# Detox Tool Component Generator Script
# Category: layout-hooks
# Description: Layout state management hooks (useLayoutState, useLayoutServices, etc.)
# Generated by: Task-Writer ScaffoldGenerator
# Implementation Phases: 1, 2
#============================================================================

# Create target directory structure
mkdir -p src/components/layout
mkdir -p src/components/ui
mkdir -p src/components/shared/forms
mkdir -p src/components/shared/generators
mkdir -p src/hooks
mkdir -p src/services
mkdir -p src/config
mkdir -p src/types

echo " Creating layout-hooks for detox-tool..."
echo " Target: ./src/"
echo ""

