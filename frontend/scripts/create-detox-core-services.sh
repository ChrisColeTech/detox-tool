# Scaffold script generated by Task Writer
# Generated on: 2025-07-01T01:16:16.782Z
# Source directory: /mnt/c/Projects/task-writer/frontend/app/src/services
# Target OS: cross-platform
# Directories: 0
# Files: 9
#
# This script will recreate the directory structure and files
# including the original file contents.

# Create files
# Create ScaffoldGeneratorService.ts
cat > "src/services/ScaffoldGeneratorService.ts" << 'EOF'
import type { QueueItem } from '@/components/ui/QueueList'
import type { TreeNode } from '@/components/ui/FileTree'
import type { PlatformService } from '@/services/platformService'

export interface ScaffoldSettings {
  targetOS: 'windows' | 'macos' | 'linux' | 'cross-platform'
  includeContent: boolean
  createDirectoriesOnly: boolean
  addComments: boolean
  scriptName: string
  outputFormat: 'powershell' | 'bash' | 'batch' | 'python' | 'nodejs' | 'ruby' | 'perl' | 'fish' | 'zsh'
  templateVariables: { [key: string]: string }
  supportedFileTypes: string[]
}

export interface GeneratedScaffold {
  id: string
  name: string
  content: string
  os: string
  fileCount: number
  directoryCount: number
  size: number
  createdAt: Date
  scriptPath?: string
  format: string
}

export interface ScaffoldGenerationStats {
  totalScripts: number
  completedScripts: number
  totalFiles: number
  totalDirectories: number
  [key: string]: number // Add index signature for compatibility
}

export interface ScaffoldGenerationProgress {
  current: number
  total: number
}

export interface ScaffoldGenerationResult {
  scaffolds: GeneratedScaffold[]
  stats: ScaffoldGenerationStats
}

export interface DirectoryResult {
  canceled: boolean
  filePaths: string[]
}

export interface ScanResult {
  tree: TreeNode[]
  stats: any
}

export interface ExportResult {
  success: boolean
  directory?: string
  filePath?: string
}

/**
 * Service class for handling scaffold generation business logic
 * Follows architecture guide principles:
 * - Single responsibility: Scaffold generation operations only
 * - No UI dependencies
 * - Pure business logic with error handling
 * - Platform service abstraction
 */
export class ScaffoldGeneratorService {
  private platformService: PlatformService
  private toastService: {
    success: (title: string, message?: string) => void
    error: (title: string, message?: string) => void
    warning: (title: string, message?: string) => void
  }

  constructor(
    platformService: PlatformService,
    toastService: {
      success: (title: string, message?: string) => void
      error: (title: string, message?: string) => void
      warning: (title: string, message?: string) => void
    }
  ) {
    this.platformService = platformService
    this.toastService = toastService
  }

  /**
   * Select directory for scaffold generation input
   */
  async selectDirectory(): Promise<string | null> {
    try {
      const result = await this.platformService.selectDirectory()
      if (result && !result.canceled) {
        const path = result.filePaths[0]
        this.toastService.success('Directory selected', path)
        return path
      }
      return null
    } catch (error) {
      this.toastService.error('Error selecting directory', 'Please try again')
      console.error('Directory selection error:', error)
      return null
    }
  }

  /**
   * Select output directory for exported scaffolds
   */
  async selectOutputDirectory(): Promise<string | null> {
    try {
      const result = await this.platformService.selectDirectory()
      if (result && !result.canceled) {
        const path = result.filePaths[0]
        this.toastService.success('Output directory selected', path)
        return path
      }
      return null
    } catch (error) {
      this.toastService.error('Error selecting output directory', 'Please try again')
      console.error('Output directory selection error:', error)
      return null
    }
  }

  /**
   * Scan directory and return file tree
   */
  async scanDirectory(path: string): Promise<TreeNode[] | null> {
    try {
      const scanResult = await this.platformService.scanDirectory(path, {
        excludeNodeModules: true,
        excludeGitIgnored: true,
        includeDotFiles: false,
        maxDepth: 10,
        maxFileSize: 50,
      })
      
      return scanResult?.tree || null
    } catch (error) {
      this.toastService.error('Directory scan failed', 'Could not analyze directory structure')
      console.error('Directory scan error:', error)
      return null
    }
  }

  /**
   * Generate scaffolds from directory with settings
   */
  async generateScaffolds(
    selectedPath: string, 
    settings: ScaffoldSettings,
    onProgress?: (progress: ScaffoldGenerationProgress) => void,
    onQueueUpdate?: (items: QueueItem[]) => void
  ): Promise<ScaffoldGenerationResult | null> {
    try {
      // Validate inputs
      if (!selectedPath) {
        this.toastService.warning('No directory selected', 'Please select an input directory first')
        return null
      }

      const validationErrors = this.validateSettings(settings)
      if (validationErrors.length > 0) {
        this.toastService.error('Invalid settings', validationErrors.join(', '))
        return null
      }

      // Create initial queue item
      const genItem: QueueItem = {
        id: 'gen-scaffold',
        name: 'Analyzing directory structure...',
        status: 'processing',
        type: 'scaffold',
        path: selectedPath,
        progress: 0,
        timestamp: new Date(),
      }

      onQueueUpdate?.([genItem])
      onProgress?.({ current: 0, total: 1 })

      // Start generation process
      const result = await this.platformService.generateScaffold(selectedPath, settings)
      
      if (!result) {
        throw new Error('No result from scaffold generation service')
      }

      // Update queue with completed status
      const completedGenItem = { ...genItem, status: 'completed' as const, progress: 100 }
      
      // Add scaffold items to queue
      const scaffoldQueueItems: QueueItem[] = result.scaffolds.map((scaffold) => ({
        id: `scaffold-${scaffold.id}`,
        name: scaffold.name,
        status: 'completed' as const,
        type: 'scaffold',
        path: scaffold.scriptPath || selectedPath,
        timestamp: new Date(),
      }))
      
      onQueueUpdate?.([completedGenItem, ...scaffoldQueueItems])
      onProgress?.(({ current: result.scaffolds.length, total: result.scaffolds.length }))
      
      this.toastService.success('Scaffold generation completed', `Created ${result.scaffolds.length} scaffold script(s)`)
      
      return result
    } catch (error) {
      // Update queue with error status
      const errorItem: QueueItem = {
        id: 'gen-scaffold',
        name: 'Analyzing directory structure...',
        status: 'error',
        type: 'scaffold',
        path: selectedPath,
        error: 'Failed to generate scaffolds',
        timestamp: new Date(),
      }
      
      onQueueUpdate?.([errorItem])
      this.toastService.error('Scaffold generation failed', 'Please check the directory and try again')
      console.error('Scaffold generation error:', error)
      return null
    }
  }

  /**
   * Export generated scaffolds to files
   */
  async exportScaffolds(scaffolds: GeneratedScaffold[]): Promise<ExportResult | null> {
    try {
      if (scaffolds.length === 0) {
        this.toastService.warning('No scaffolds generated', 'Please generate scaffolds first')
        return null
      }

      const result = await this.platformService.exportScaffolds(scaffolds)
      
      if (result?.success) {
        this.toastService.success('Scaffolds exported', `Saved ${scaffolds.length} script(s) to ${result.directory}`)
        return result
      }
      
      throw new Error('Export operation failed')
    } catch (error) {
      this.toastService.error('Export failed', 'Could not save scaffold files')
      console.error('Scaffold export error:', error)
      return null
    }
  }

  /**
   * Export single scaffold to file
   */
  async exportSingleScaffold(scaffold: GeneratedScaffold): Promise<ExportResult | null> {
    try {
      const result = await this.platformService.exportSingleScaffold(scaffold)
      
      if (result?.success) {
        this.toastService.success('Scaffold exported', `Saved to ${result.filePath}`)
        return result
      }
      
      throw new Error('Single scaffold export failed')
    } catch (error) {
      this.toastService.error('Export failed', 'Could not save scaffold file')
      console.error('Single scaffold export error:', error)
      return null
    }
  }

  /**
   * Validate scaffold generation settings
   */
  validateSettings(settings: ScaffoldSettings): string[] {
    const errors: string[] = []

    if (!settings.scriptName || settings.scriptName.trim().length === 0) {
      errors.push('Script name is required')
    }

    if (settings.scriptName && settings.scriptName.length > 100) {
      errors.push('Script name should not exceed 100 characters')
    }

    // Validate script name contains only safe characters
    if (settings.scriptName && !/^[a-zA-Z0-9_-]+$/.test(settings.scriptName)) {
      errors.push('Script name should only contain letters, numbers, underscores, and hyphens')
    }

    if (settings.supportedFileTypes && settings.supportedFileTypes.length === 0) {
      errors.push('At least one file type should be supported')
    }

    return errors
  }

  /**
   * Get default scaffold generation settings
   */
  getDefaultSettings(): ScaffoldSettings {
    return {
      targetOS: 'cross-platform',
      includeContent: false,
      createDirectoriesOnly: false,
      addComments: true,
      scriptName: 'scaffold',
      outputFormat: 'bash',
      templateVariables: {},
      supportedFileTypes: ['.js', '.ts', '.tsx', '.jsx', '.py', '.java', '.c', '.cpp', '.h', '.cs', '.rb', '.php', '.go', '.rs', '.swift', '.kt', '.scala', '.clj', '.hs', '.ml', '.f90', '.pl', '.sh', '.ps1', '.bat', '.cmd', '.fish', '.zsh']
    }
  }

  /**
   * Get supported output formats for target OS
   */
  getSupportedFormats(targetOS: ScaffoldSettings['targetOS']): ScaffoldSettings['outputFormat'][] {
    switch (targetOS) {
      case 'windows':
        return ['powershell', 'batch', 'python', 'nodejs']
      case 'macos':
        return ['bash', 'zsh', 'fish', 'python', 'nodejs', 'ruby', 'perl']
      case 'linux':
        return ['bash', 'fish', 'zsh', 'python', 'nodejs', 'ruby', 'perl']
      case 'cross-platform':
        return ['python', 'nodejs', 'ruby', 'perl']
      default:
        return ['bash']
    }
  }

  /**
   * Get default output format for target OS
   */
  getDefaultFormat(targetOS: ScaffoldSettings['targetOS']): ScaffoldSettings['outputFormat'] {
    switch (targetOS) {
      case 'windows':
        return 'powershell'
      case 'macos':
        return 'zsh'
      case 'linux':
        return 'bash'
      case 'cross-platform':
        return 'python'
      default:
        return 'bash'
    }
  }
}
EOF

# Create TaskGeneratorService.ts
cat > "src/services/TaskGeneratorService.ts" << 'EOF'
import type { QueueItem } from '@/components/ui/QueueList'
import type { TreeNode } from '@/components/ui/FileTree'
import type { PlatformService } from '@/services/platformService'

export interface TaskSettings {
  includeFileContents: boolean
  includeFolderStructure: boolean
  includeImplementationSteps: boolean
  groupByDirectory: boolean
  outputFormat: 'markdown' | 'text' | 'html'
  maxFileSize: number // MB
  filesPerTask: number
  customInstructions: string
}

export interface GeneratedTask {
  id: string
  name: string
  content: string
  directory: string
  fileCount: number
  size: number
  createdAt: Date
}

export interface GenerationStats {
  totalTasks: number
  completedTasks: number
  totalFiles: number
  processedFiles: number
  [key: string]: number // Add index signature for compatibility
}

export interface GenerationProgress {
  current: number
  total: number
}

export interface TaskGenerationResult {
  tasks: GeneratedTask[]
  stats: GenerationStats
}

export interface DirectoryResult {
  canceled: boolean
  filePaths: string[]
}

export interface ScanResult {
  tree: TreeNode[]
  stats: any
}

export interface ExportResult {
  success: boolean
  directory?: string
  filePath?: string
}

/**
 * Service class for handling task generation business logic
 * Follows architecture guide principles:
 * - Single responsibility: Task generation operations only
 * - No UI dependencies
 * - Pure business logic with error handling
 * - Platform service abstraction
 */
export class TaskGeneratorService {
  private platformService: PlatformService
  private toastService: {
    success: (title: string, message?: string) => void
    error: (title: string, message?: string) => void
    warning: (title: string, message?: string) => void
  }

  constructor(
    platformService: PlatformService,
    toastService: {
      success: (title: string, message?: string) => void
      error: (title: string, message?: string) => void
      warning: (title: string, message?: string) => void
    }
  ) {
    this.platformService = platformService
    this.toastService = toastService
  }

  /**
   * Select directory for task generation input
   */
  async selectDirectory(): Promise<string | null> {
    try {
      const result = await this.platformService.selectDirectory()
      if (result && !result.canceled) {
        const path = result.filePaths[0]
        this.toastService.success('Directory selected', path)
        return path
      }
      return null
    } catch (error) {
      this.toastService.error('Error selecting directory', 'Please try again')
      console.error('Directory selection error:', error)
      return null
    }
  }

  /**
   * Select output directory for exported tasks
   */
  async selectOutputDirectory(): Promise<string | null> {
    try {
      const result = await this.platformService.selectDirectory()
      if (result && !result.canceled) {
        const path = result.filePaths[0]
        this.toastService.success('Output directory selected', path)
        return path
      }
      return null
    } catch (error) {
      this.toastService.error('Error selecting output directory', 'Please try again')
      console.error('Output directory selection error:', error)
      return null
    }
  }

  /**
   * Scan directory and return file tree
   */
  async scanDirectory(path: string): Promise<TreeNode[] | null> {
    try {
      const scanResult = await this.platformService.scanDirectory(path, {
        excludeNodeModules: true,
        excludeGitIgnored: true,
        includeDotFiles: false,
        maxDepth: 10,
        maxFileSize: 50,
      })
      
      return scanResult?.tree || null
    } catch (error) {
      this.toastService.error('Directory scan failed', 'Could not analyze directory structure')
      console.error('Directory scan error:', error)
      return null
    }
  }

  /**
   * Generate tasks from directory with settings
   */
  async generateTasks(
    selectedPath: string, 
    settings: TaskSettings,
    onProgress?: (progress: GenerationProgress) => void,
    onQueueUpdate?: (items: QueueItem[]) => void
  ): Promise<TaskGenerationResult | null> {
    try {
      // Validate inputs
      if (!selectedPath) {
        this.toastService.warning('No directory selected', 'Please select an input directory first')
        return null
      }

      // Create initial queue item
      const genItem: QueueItem = {
        id: 'gen-root',
        name: 'Analyzing directory structure...',
        status: 'processing',
        type: 'task',
        path: selectedPath,
        progress: 0,
        timestamp: new Date(),
      }

      onQueueUpdate?.([genItem])
      onProgress?.({ current: 0, total: 1 })

      // Start generation process
      const result = await this.platformService.generateTasks(selectedPath, settings)
      
      if (!result) {
        throw new Error('No result from generation service')
      }

      // Update queue with completed status
      const completedGenItem = { ...genItem, status: 'completed' as const, progress: 100 }
      
      // Add task items to queue
      const taskQueueItems: QueueItem[] = result.tasks.map((task) => ({
        id: `task-${task.id}`,
        name: task.name,
        status: 'completed' as const,
        type: 'task',
        path: task.directory,
        timestamp: new Date(),
      }))
      
      onQueueUpdate?.([completedGenItem, ...taskQueueItems])
      onProgress?.(({ current: result.tasks.length, total: result.tasks.length }))
      
      this.toastService.success('Generation completed', `Created ${result.tasks.length} task files`)
      
      return result
    } catch (error) {
      // Update queue with error status
      const errorItem: QueueItem = {
        id: 'gen-root',
        name: 'Analyzing directory structure...',
        status: 'error',
        type: 'task',
        path: selectedPath,
        error: 'Failed to generate tasks',
        timestamp: new Date(),
      }
      
      onQueueUpdate?.([errorItem])
      this.toastService.error('Generation failed', 'Please check the directory and try again')
      console.error('Generation error:', error)
      return null
    }
  }

  /**
   * Export generated tasks to files
   */
  async exportTasks(
    tasks: GeneratedTask[], 
    outputFormat: TaskSettings['outputFormat']
  ): Promise<ExportResult | null> {
    try {
      if (tasks.length === 0) {
        this.toastService.warning('No tasks generated', 'Please generate tasks first')
        return null
      }

      const result = await this.platformService.exportTasks(tasks, outputFormat)
      
      if (result?.success) {
        this.toastService.success('Tasks exported', `Saved ${tasks.length} files to ${result.directory}`)
        return result
      }
      
      throw new Error('Export operation failed')
    } catch (error) {
      this.toastService.error('Export failed', 'Could not save task files')
      console.error('Export error:', error)
      return null
    }
  }

  /**
   * Export single task to file
   */
  async exportSingleTask(task: GeneratedTask): Promise<ExportResult | null> {
    try {
      const result = await this.platformService.exportSingleTask(task)
      
      if (result?.success) {
        this.toastService.success('Task exported', `Saved to ${result.filePath}`)
        return result
      }
      
      throw new Error('Single task export failed')
    } catch (error) {
      this.toastService.error('Export failed', 'Could not save task file')
      console.error('Single task export error:', error)
      return null
    }
  }

  /**
   * Validate task generation settings
   */
  validateSettings(settings: TaskSettings): string[] {
    const errors: string[] = []

    if (settings.maxFileSize <= 0) {
      errors.push('Max file size must be greater than 0')
    }

    if (settings.filesPerTask <= 0) {
      errors.push('Files per task must be greater than 0')
    }

    if (settings.maxFileSize > 100) {
      errors.push('Max file size should not exceed 100MB for performance')
    }

    if (settings.filesPerTask > 50) {
      errors.push('Files per task should not exceed 50 for manageable task sizes')
    }

    return errors
  }

  /**
   * Get default task generation settings
   */
  getDefaultSettings(): TaskSettings {
    return {
      includeFileContents: true,
      includeFolderStructure: true,
      includeImplementationSteps: true,
      groupByDirectory: true,
      outputFormat: 'markdown',
      maxFileSize: 10,
      filesPerTask: 5,
      customInstructions: '',
    }
  }
}
EOF

# Create appService.ts
cat > "src/services/appService.ts" << 'EOF'
import { initializeNavigationService, NavigationService } from './navigationService'
import { initializeTabService, TabService, type TabCallbacks } from './tabService'
import { getNavigationItem } from '../config/navigationConfig'

export interface AppServiceCallbacks extends TabCallbacks {
  onSidebarChange: (tabId: string) => void
}

export class AppService {
  private navigationService: NavigationService
  private tabService: TabService
  private sidebarActiveTab: string = ''

  constructor(callbacks: AppServiceCallbacks) {
    this.tabService = initializeTabService({
      onTabAdd: callbacks.onTabAdd,
      onTabRemove: callbacks.onTabRemove,
      onTabActivate: callbacks.onTabActivate,
    })
    this.navigationService = initializeNavigationService({
      onTabAdd: (tab) => this.tabService.addTab(tab),
      onTabRemove: (tabId) => this.tabService.removeTab(tabId),
      onTabActivate: (tabId) => this.tabService.activateTab(tabId),
      onSidebarChange: (tabId) => {
        this.sidebarActiveTab = tabId
        callbacks.onSidebarChange(tabId)
      },
    })
  }

  openTab(itemId: string, activateTab: boolean = true): boolean {
    return this.navigationService.openTab(itemId, activateTab)
  }

  changeSidebarItem(itemId: string): boolean {
    const changed = this.navigationService.changeSidebarItem(itemId)
    if (changed) {
      this.navigationService.openTab(itemId, true)
    }
    return changed
  }

  openSettings(): void {
    this.navigationService.openSettings()
  }

  handleTabClick(tabId: string): void {
    this.tabService.activateTab(tabId)
    const navigationItem = getNavigationItem(tabId)
    if (navigationItem) {
      this.navigationService.changeSidebarItem(tabId)
    }
  }

  handleTabClose(tabId: string): void {
    this.tabService.removeTab(tabId)
  }

  getSidebarActiveTab(): string {
    return this.sidebarActiveTab
  }
}

let appServiceInstance: AppService | null = null
export const getAppService = (): AppService | null => appServiceInstance
export const initializeAppService = (callbacks: AppServiceCallbacks): AppService => {
  if (appServiceInstance) {
    return appServiceInstance
  }
  appServiceInstance = new AppService(callbacks)
  return appServiceInstance
}

EOF

# Create browserService.ts
cat > "src/services/browserService.ts" << 'EOF'
import type { FileQueueItem } from '@/types/electron-api'

export class BrowserService {
  private readonly SETTINGS_STORAGE_KEY = 'app-settings'
  private readonly FILE_QUEUE_STORAGE_KEY = 'app-file-queue'

  constructor() {
    // BrowserService initialized
  }

  async saveSettings(settings: Record<string, unknown>): Promise<void> {
    try {
      localStorage.setItem(this.SETTINGS_STORAGE_KEY, JSON.stringify(settings))
    } catch (error) {
      console.error('Failed to save settings to localStorage:', error)
      throw new Error('Failed to save settings')
    }
  }

  async loadSettings(): Promise<Record<string, unknown> | null> {
    try {
      const stored = localStorage.getItem(this.SETTINGS_STORAGE_KEY)
      if (stored) {
        const parsed = JSON.parse(stored)
        return parsed
      }
      return null
    } catch (error) {
      console.error('Failed to load settings from localStorage:', error)
      return null
    }
  }

  async openFile(): Promise<{ path: string; content: string } | null> {
    return new Promise((resolve) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = '*/*'

      input.onchange = (event) => {
        const file = (event.target as HTMLInputElement).files?.[0]
        if (file) {
          const reader = new FileReader()
          reader.onload = (e) => {
            const content = e.target?.result as string
            resolve({
              path: file.name,
              content: content,
            })
          }
          reader.onerror = () => {
            console.error('Failed to read file')
            resolve(null)
          }
          reader.readAsText(file)
        } else {
          resolve(null)
        }
      }

      input.oncancel = () => resolve(null)
      input.click()
    })
  }

  async saveFile(path: string, content: string): Promise<boolean> {
    try {
      const blob = new Blob([content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)

      const a = document.createElement('a')
      a.href = url
      a.download = path.split('/').pop() || 'file.txt'
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)

      URL.revokeObjectURL(url)
      return true
    } catch (error) {
      console.error('Failed to save file:', error)
      return false
    }
  }

  async saveFileAs(content: string): Promise<{ path: string; success: boolean } | null> {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
      const defaultFilename = `file-${timestamp}.txt`

      const blob = new Blob([content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)

      const a = document.createElement('a')
      a.href = url
      a.download = defaultFilename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)

      URL.revokeObjectURL(url)

      return {
        path: defaultFilename,
        success: true,
      }
    } catch (error) {
      console.error('Failed to save file as:', error)
      return null
    }
  }

  minimizeWindow(): void {
    console.log('Mock: Window minimize requested (not supported in browser)')
  }

  async maximizeWindow(): Promise<void> {
    console.log('Mock: Window maximize requested')
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch((err) => {
        console.log('Failed to enter fullscreen:', err)
      })
    }
  }

  closeWindow(): void {
    console.log('Mock: Window close requested')
    if (confirm('Are you sure you want to close this tab?')) {
      window.close()
    }
  }

  async isMaximized(): Promise<boolean> {
    return !!document.fullscreenElement
  }

  async showSaveDialog(defaultPath?: string): Promise<string | null> {
    console.log('Mock: Save dialog requested with default path:', defaultPath)

    const filename = prompt('Enter filename to save:', defaultPath || 'file.txt')
    return filename
  }

  async showOpenDialog(): Promise<string[] | null> {
    console.log('Mock: Open dialog requested')

    return new Promise((resolve) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.multiple = true
      input.accept = '*/*'

      input.onchange = (event) => {
        const files = Array.from((event.target as HTMLInputElement).files || [])
        const filenames = files.map((file) => file.name)
        resolve(filenames.length > 0 ? filenames : null)
      }

      input.oncancel = () => resolve(null)
      input.click()
    })
  }

  async showMessageBox(
    message: string,
    type: 'info' | 'warning' | 'error' = 'info',
  ): Promise<void> {
    console.log(`Mock: Message box (${type}):`, message)

    switch (type) {
      case 'error':
        alert(`Error: ${message}`)
        break
      case 'warning':
        alert(`Warning: ${message}`)
        break
      case 'info':
      default:
        alert(message)
        break
    }
  }

  async saveFileQueue(queue: FileQueueItem[]): Promise<void> {
    try {
      localStorage.setItem(this.FILE_QUEUE_STORAGE_KEY, JSON.stringify(queue))
    } catch (error) {
      console.error('Failed to save file queue to localStorage:', error)
      throw new Error('Failed to save file queue')
    }
  }

  async loadFileQueue(): Promise<FileQueueItem[] | null> {
    try {
      const stored = localStorage.getItem(this.FILE_QUEUE_STORAGE_KEY)
      if (stored) {
        const parsed = JSON.parse(stored)
        return parsed
      }
      return null
    } catch (error) {
      console.error('Failed to load file queue from localStorage:', error)
      return null
    }
  }

  async exportFileQueue(queue: FileQueueItem[]): Promise<string | null> {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
      const filename = `file-queue-${timestamp}.json`
      const content = JSON.stringify(queue, null, 2)

      const blob = new Blob([content], { type: 'application/json' })
      const url = URL.createObjectURL(blob)

      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)

      URL.revokeObjectURL(url)
      return filename
    } catch (error) {
      console.error('Failed to export file queue:', error)
      return null
    }
  }

  async importFileQueue(): Promise<FileQueueItem[] | null> {
    return new Promise((resolve) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = '.json'

      input.onchange = (event) => {
        const file = (event.target as HTMLInputElement).files?.[0]
        if (file) {
          const reader = new FileReader()
          reader.onload = (e) => {
            try {
              const content = e.target?.result as string
              const queue = JSON.parse(content)
              resolve(queue)
            } catch (error) {
              console.error('Failed to parse imported file queue:', error)
              resolve(null)
            }
          }
          reader.onerror = () => {
            console.error('Failed to read file queue file')
            resolve(null)
          }
          reader.readAsText(file)
        } else {
          resolve(null)
        }
      }

      input.oncancel = () => resolve(null)
      input.click()
    })
  }

  // Task Writer specific methods - Browser implementation
  async selectDirectory(): Promise<{ canceled: boolean; filePaths: string[] } | null> {
    return new Promise((resolve) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.webkitdirectory = true
      input.multiple = true

      input.onchange = (event) => {
        const files = (event.target as HTMLInputElement).files
        if (files && files.length > 0) {
          // Get the folder name from the first file's path
          const firstFile = files[0]
          const pathParts = firstFile.webkitRelativePath.split('/')
          const folderName = pathParts[0]
          
          resolve({
            canceled: false,
            filePaths: [folderName]
          })
        } else {
          resolve({ canceled: true, filePaths: [] })
        }
      }

      input.oncancel = () => resolve({ canceled: true, filePaths: [] })
      input.click()
    })
  }

  async scanDirectory(_path: string, _settings: any): Promise<{ tree: any[]; stats: any } | null> {
    // Browser fallback: return mock data or error
    console.warn('Directory scanning is not available in browser mode')
    void _path; void _settings;
    return null
  }

  async exportScanResults(tree: any[], stats: any): Promise<{ success: boolean; filePath: string } | null> {
    // Browser fallback: download as JSON
    try {
      const data = { tree, stats }
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = 'scan-results.json'
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      
      URL.revokeObjectURL(url)
      return { success: true, filePath: 'scan-results.json' }
    } catch {
      return null
    }
  }

  async generateTasks(_path: string, _settings: any): Promise<{ tasks: any[]; stats: any } | null> {
    // Browser fallback: not available
    console.warn('Task generation is not available in browser mode')
    void _path; void _settings;
    return null
  }

  async exportTasks(tasks: any[], format: string): Promise<{ success: boolean; directory: string } | null> {
    // Browser fallback: download as files
    try {
      for (const task of tasks) {
        const blob = new Blob([task.content], { type: 'text/plain' })
        const url = URL.createObjectURL(blob)
        
        const a = document.createElement('a')
        a.href = url
        a.download = `${task.name}.${format}`
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        
        URL.revokeObjectURL(url)
      }
      return { success: true, directory: 'Downloads' }
    } catch {
      return null
    }
  }

  async exportSingleTask(task: any): Promise<{ success: boolean; filePath: string } | null> {
    // Browser fallback: download single file
    try {
      const blob = new Blob([task.content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = `${task.name}.txt`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      
      URL.revokeObjectURL(url)
      return { success: true, filePath: `${task.name}.txt` }
    } catch {
      return null
    }
  }

  async generateScaffold(_path: string, _settings: any): Promise<{ scaffolds: any[]; stats: any } | null> {
    // Browser fallback: not available
    console.warn('Scaffold generation is not available in browser mode')
    void _path; void _settings;
    return null
  }

  async exportScaffolds(scaffolds: any[]): Promise<{ success: boolean; directory: string } | null> {
    // Browser fallback: download as files
    try {
      for (const scaffold of scaffolds) {
        const blob = new Blob([scaffold.content], { type: 'text/plain' })
        const url = URL.createObjectURL(blob)
        
        const a = document.createElement('a')
        a.href = url
        a.download = `${scaffold.name}.${scaffold.format}`
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        
        URL.revokeObjectURL(url)
      }
      return { success: true, directory: 'Downloads' }
    } catch {
      return null
    }
  }

  async exportSingleScaffold(scaffold: any): Promise<{ success: boolean; filePath: string } | null> {
    // Browser fallback: download single file
    try {
      const blob = new Blob([scaffold.content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = `${scaffold.name}.${scaffold.format}`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      
      URL.revokeObjectURL(url)
      return { success: true, filePath: `${scaffold.name}.${scaffold.format}` }
    } catch {
      return null
    }
  }
}

EOF

# Create electronService.ts
cat > "src/services/electronService.ts" << 'EOF'
import type { ElectronAPI, FileQueueItem } from '@/types/electron-api'

export class ElectronService {
  private electronAPI: ElectronAPI | undefined

  constructor() {
    this.electronAPI = (window as Window).electronAPI
  }

  isAvailable(): boolean {
    return !!this.electronAPI
  }

  async saveSettings(settings: Record<string, unknown>): Promise<void> {
    try {
      if (this.isAvailable() && this.electronAPI?.storage) {
        await this.electronAPI.storage.saveSettings(settings)
      }
    } catch (error) {
      console.error('Failed to save settings via Electron:', error)
      throw new Error('Settings save failed')
    }
  }

  async loadSettings(): Promise<Record<string, unknown> | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.storage) {
        return await this.electronAPI.storage.loadSettings()
      }
      return null
    } catch (error) {
      console.error('Failed to load settings via Electron:', error)
      return null
    }
  }

  async openFile(): Promise<{ path: string; content: string } | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.file) {
        return await this.electronAPI.file.openFile()
      }
      return null
    } catch (error) {
      console.error('Failed to open file via Electron:', error)
      return null
    }
  }

  async saveFile(path: string, content: string): Promise<boolean> {
    try {
      if (this.isAvailable() && this.electronAPI?.file) {
        return await this.electronAPI.file.saveFile(path, content)
      }
      return false
    } catch (error) {
      console.error('Failed to save file via Electron:', error)
      return false
    }
  }

  async saveFileAs(content: string): Promise<{ path: string; success: boolean } | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.file) {
        return await this.electronAPI.file.saveFileAs(content)
      }
      return null
    } catch (error) {
      console.error('Failed to save file as via Electron:', error)
      return null
    }
  }

  async saveFileQueue(queue: FileQueueItem[]): Promise<void> {
    try {
      if (this.isAvailable() && this.electronAPI?.fileQueue) {
        await this.electronAPI.fileQueue.saveFileQueue(queue)
      }
    } catch (error) {
      console.error('Failed to save file queue via Electron:', error)
      throw new Error('File queue save failed')
    }
  }

  async loadFileQueue(): Promise<FileQueueItem[] | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.fileQueue) {
        return await this.electronAPI.fileQueue.loadFileQueue()
      }
      return null
    } catch (error) {
      console.error('Failed to load file queue via Electron:', error)
      return null
    }
  }

  async exportFileQueue(queue: FileQueueItem[]): Promise<string | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.fileQueue) {
        return await this.electronAPI.fileQueue.exportFileQueue(queue)
      }
      return null
    } catch (error) {
      console.error('Failed to export file queue via Electron:', error)
      return null
    }
  }

  async importFileQueue(): Promise<FileQueueItem[] | null> {
    try {
      if (this.isAvailable() && this.electronAPI?.fileQueue) {
        return await this.electronAPI.fileQueue.importFileQueue()
      }
      return null
    } catch (error) {
      console.error('Failed to import file queue via Electron:', error)
      return null
    }
  }

  async minimizeWindow(): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.minimize()
    }
  }

  async maximizeWindow(): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.maximize()
    }
  }

  closeWindow(): void {
    if (this.isAvailable() && this.electronAPI?.window) {
      this.electronAPI.window.close()
    }
  }

  async isMaximized(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.window) {
      return this.electronAPI.window.isMaximized()
    }
    return false
  }

  async showSaveDialog(defaultPath?: string): Promise<string | null> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      return await this.electronAPI.dialog.showSaveDialog(defaultPath)
    }
    return null
  }

  async showOpenDialog(): Promise<string[] | null> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      return await this.electronAPI.dialog.showOpenDialog()
    }
    return null
  }

  async showMessageBox(message: string, type?: 'info' | 'warning' | 'error'): Promise<void> {
    if (this.isAvailable() && this.electronAPI?.dialog) {
      await this.electronAPI.dialog.showMessageBox(message, type)
    }
  }

  async startApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.startApiProcess) {
      return await this.electronAPI.startApiProcess()
    }
    return false
  }

  async stopApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.stopApiProcess) {
      return await this.electronAPI.stopApiProcess()
    }
    return false
  }

  async restartApiProcess(): Promise<boolean> {
    if (this.isAvailable() && this.electronAPI?.restartApiProcess) {
      return await this.electronAPI.restartApiProcess()
    }
    return false
  }

  async getApiStatus(): Promise<{ isRunning: boolean; pid: number | null }> {
    if (this.isAvailable() && this.electronAPI?.getApiStatus) {
      return await this.electronAPI.getApiStatus()
    }
    return { isRunning: false, pid: null }
  }

  onWindowStateChange(callback: (state: { isMaximized: boolean }) => void): () => void {
    if (this.isAvailable() && this.electronAPI?.onWindowStateChange) {
      return this.electronAPI.onWindowStateChange(callback)
    }
    return () => {} // Return no-op function
  }

  getVersion(): string {
    if (this.isAvailable() && this.electronAPI?.app) {
      return this.electronAPI.app.getVersion()
    }
    return '1.0.0'
  }

  getPath(): string {
    if (this.isAvailable() && this.electronAPI?.app) {
      return this.electronAPI.app.getPath()
    }
    return ''
  }

  openDevTools(): void {
    if (this.isAvailable() && this.electronAPI?.dev) {
      this.electronAPI.dev.openDevTools()
    }
  }

  reload(): void {
    if (this.isAvailable() && this.electronAPI?.dev) {
      this.electronAPI.dev.reload()
    }
  }

  // Task Writer specific methods
  async selectDirectory(): Promise<{ canceled: boolean; filePaths: string[] } | null> {
    if (this.isAvailable() && this.electronAPI?.selectDirectory) {
      return await this.electronAPI.selectDirectory()
    }
    return null
  }

  async scanDirectory(path: string, settings: any): Promise<{ tree: any[]; stats: any } | null> {
    if (this.isAvailable() && this.electronAPI?.scanDirectory) {
      return await this.electronAPI.scanDirectory(path, settings)
    }
    return null
  }

  async exportScanResults(tree: any[], stats: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this.isAvailable() && this.electronAPI?.exportScanResults) {
      return await this.electronAPI.exportScanResults(tree, stats)
    }
    return null
  }

  async generateTasks(path: string, settings: any): Promise<{ tasks: any[]; stats: any } | null> {
    if (this.isAvailable() && this.electronAPI?.generateTasks) {
      return await this.electronAPI.generateTasks(path, settings)
    }
    return null
  }

  async exportTasks(tasks: any[], format: string): Promise<{ success: boolean; directory: string } | null> {
    if (this.isAvailable() && this.electronAPI?.exportTasks) {
      return await this.electronAPI.exportTasks(tasks, format)
    }
    return null
  }

  async exportSingleTask(task: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this.isAvailable() && this.electronAPI?.exportSingleTask) {
      return await this.electronAPI.exportSingleTask(task)
    }
    return null
  }

  async generateScaffold(path: string, settings: any): Promise<{ scaffolds: any[]; stats: any } | null> {
    if (this.isAvailable() && this.electronAPI?.generateScaffold) {
      return await this.electronAPI.generateScaffold(path, settings)
    }
    return null
  }

  async exportScaffolds(scaffolds: any[]): Promise<{ success: boolean; directory: string } | null> {
    if (this.isAvailable() && this.electronAPI?.exportScaffolds) {
      return await this.electronAPI.exportScaffolds(scaffolds)
    }
    return null
  }

  async exportSingleScaffold(scaffold: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this.isAvailable() && this.electronAPI?.exportSingleScaffold) {
      return await this.electronAPI.exportSingleScaffold(scaffold)
    }
    return null
  }
}

EOF

# Create navigationService.ts
cat > "src/services/navigationService.ts" << 'EOF'
import { getNavigationItem, getTabIcon, getTabTitle } from '../config/navigationConfig'
import type { Tab } from '../types/tab'

export class NavigationService {
  private onTabAdd?: (tab: Tab) => void
  private onTabRemove?: (tabId: string) => void
  private onTabActivate?: (tabId: string) => void
  private onSidebarChange?: (tabId: string) => void

  constructor(callbacks?: {
    onTabAdd?: (tab: Tab) => void
    onTabRemove?: (tabId: string) => void
    onTabActivate?: (tabId: string) => void
    onSidebarChange?: (tabId: string) => void
  }) {
    this.onTabAdd = callbacks?.onTabAdd
    this.onTabRemove = callbacks?.onTabRemove
    this.onTabActivate = callbacks?.onTabActivate
    this.onSidebarChange = callbacks?.onSidebarChange
  }

  openTab(itemId: string, activateTab: boolean = true): boolean {
    const navigationItem = getNavigationItem(itemId)
    if (!navigationItem) return false

    const tab: Tab = {
      id: itemId,
      title: getTabTitle(itemId),
      label: getTabTitle(itemId),
      icon: getTabIcon(itemId),
      closable: navigationItem.closable !== undefined ? navigationItem.closable : true,
      isActive: activateTab,
    }
    this.onTabAdd?.(tab)
    if (activateTab) this.onTabActivate?.(itemId)
    return true
  }

  closeTab(tabId: string): void {
    this.onTabRemove?.(tabId)
  }

  activateTab(tabId: string): void {
    this.onTabActivate?.(tabId)
  }

  changeSidebarItem(itemId: string): boolean {
    const navigationItem = getNavigationItem(itemId)
    if (!navigationItem) return false
    this.onSidebarChange?.(itemId)
    return true
  }

  openSettings(): void {
    this.changeSidebarItem('settings')
    this.openTab('settings', true)
  }

  validateItemExists(itemId: string): boolean {
    const navigationItem = getNavigationItem(itemId)
    return navigationItem !== undefined
  }
}

let navigationServiceInstance: NavigationService | null = null
export const getNavigationService = (): NavigationService | null => navigationServiceInstance
export const initializeNavigationService = (callbacks: {
  onTabAdd?: (tab: Tab) => void
  onTabRemove?: (tabId: string) => void
  onTabActivate?: (tabId: string) => void
  onSidebarChange?: (tabId: string) => void
}): NavigationService => {
  navigationServiceInstance = new NavigationService(callbacks)
  return navigationServiceInstance
}

EOF

# Create platformService.ts
cat > "src/services/platformService.ts" << 'EOF'
import { BrowserService } from '@/services/browserService'
import { ElectronService } from '@/services/electronService'
import type { FileQueueItem } from '@/types/electron-api'

export interface PlatformService {
  saveSettings(settings: Record<string, unknown>): Promise<void>
  loadSettings(): Promise<Record<string, unknown> | null>

  openFile(): Promise<{ path: string; content: string } | null>
  saveFile(path: string, content: string): Promise<boolean>
  saveFileAs(content: string): Promise<{ path: string; success: boolean } | null>

  saveFileQueue(files: FileQueueItem[]): Promise<void>
  loadFileQueue(): Promise<FileQueueItem[] | null>
  exportFileQueue(files: FileQueueItem[]): Promise<string | null>
  importFileQueue(): Promise<FileQueueItem[] | null>

  minimizeWindow(): void
  maximizeWindow(): Promise<void>
  closeWindow(): void
  isMaximized(): Promise<boolean>
  onWindowStateChange(callback: (state: { isMaximized: boolean }) => void): () => void

  showSaveDialog(defaultPath?: string): Promise<string | null>
  showOpenDialog(): Promise<string[] | null>
  showMessageBox(message: string, type?: 'info' | 'warning' | 'error'): Promise<void>

  isElectron(): boolean
  isBrowser(): boolean
  isMac(): boolean
  getPlatform(): 'electron' | 'browser'

  // Task Writer specific methods
  selectDirectory(): Promise<{ canceled: boolean; filePaths: string[] } | null>
  scanDirectory(path: string, settings: any): Promise<{ tree: any[]; stats: any } | null>
  exportScanResults(tree: any[], stats: any): Promise<{ success: boolean; filePath: string } | null>
  generateTasks(path: string, settings: any): Promise<{ tasks: any[]; stats: any } | null>
  exportTasks(tasks: any[], format: string): Promise<{ success: boolean; directory: string } | null>
  exportSingleTask(task: any): Promise<{ success: boolean; filePath: string } | null>
  generateScaffold(path: string, settings: any): Promise<{ scaffolds: any[]; stats: any } | null>
  exportScaffolds(scaffolds: any[]): Promise<{ success: boolean; directory: string } | null>
  exportSingleScaffold(scaffold: any): Promise<{ success: boolean; filePath: string } | null>
}

class PlatformServiceImpl implements PlatformService {
  private electronService: ElectronService
  private browserService: BrowserService
  private _isElectron: boolean

  constructor() {
    this._isElectron =
      !!(window as Window & { electronAPI?: unknown }).electronAPI ||
      !!(window as Window & { require?: unknown }).require

    // Debug logging
    console.log('Platform detection:', {
      hasElectronAPI: !!(window as Window & { electronAPI?: unknown }).electronAPI,
      hasRequire: !!(window as Window & { require?: unknown }).require,
      isElectron: this._isElectron,
      userAgent: navigator.userAgent
    })

    this.electronService = new ElectronService()
    this.browserService = new BrowserService()
  }

  isElectron(): boolean {
    return this._isElectron
  }

  isBrowser(): boolean {
    return !this._isElectron
  }

  isMac(): boolean {
    return navigator.platform.toUpperCase().indexOf('MAC') >= 0
  }

  getPlatform(): 'electron' | 'browser' {
    return this._isElectron ? 'electron' : 'browser'
  }

  async saveSettings(settings: Record<string, unknown>): Promise<void> {
    if (this._isElectron) {
      return this.electronService.saveSettings(settings)
    } else {
      return this.browserService.saveSettings(settings)
    }
  }

  async loadSettings(): Promise<Record<string, unknown> | null> {
    if (this._isElectron) {
      return this.electronService.loadSettings()
    } else {
      return this.browserService.loadSettings()
    }
  }

  async openFile(): Promise<{ path: string; content: string } | null> {
    if (this._isElectron) {
      return this.electronService.openFile()
    } else {
      return this.browserService.openFile()
    }
  }

  async saveFile(path: string, content: string): Promise<boolean> {
    if (this._isElectron) {
      return this.electronService.saveFile(path, content)
    } else {
      return this.browserService.saveFile(path, content)
    }
  }

  async saveFileAs(content: string): Promise<{ path: string; success: boolean } | null> {
    if (this._isElectron) {
      return this.electronService.saveFileAs(content)
    } else {
      return this.browserService.saveFileAs(content)
    }
  }

  async saveFileQueue(files: FileQueueItem[]): Promise<void> {
    if (this._isElectron) {
      return this.electronService.saveFileQueue(files)
    } else {
      return this.browserService.saveFileQueue(files)
    }
  }

  async loadFileQueue(): Promise<FileQueueItem[] | null> {
    if (this._isElectron) {
      return this.electronService.loadFileQueue()
    } else {
      return this.browserService.loadFileQueue()
    }
  }

  async exportFileQueue(files: FileQueueItem[]): Promise<string | null> {
    if (this._isElectron) {
      return this.electronService.exportFileQueue(files)
    } else {
      return this.browserService.exportFileQueue(files)
    }
  }

  async importFileQueue(): Promise<FileQueueItem[] | null> {
    if (this._isElectron) {
      return this.electronService.importFileQueue()
    } else {
      return this.browserService.importFileQueue()
    }
  }

  minimizeWindow(): void {
    if (this._isElectron) {
      this.electronService.minimizeWindow()
    } else {
      this.browserService.minimizeWindow()
    }
  }

  async maximizeWindow(): Promise<void> {
    if (this._isElectron) {
      await this.electronService.maximizeWindow()
    } else {
      await this.browserService.maximizeWindow()
    }
  }

  closeWindow(): void {
    if (this._isElectron) {
      this.electronService.closeWindow()
    } else {
      this.browserService.closeWindow()
    }
  }

  async isMaximized(): Promise<boolean> {
    if (this._isElectron) {
      return await this.electronService.isMaximized()
    } else {
      return await this.browserService.isMaximized()
    }
  }

  onWindowStateChange(callback: (state: { isMaximized: boolean }) => void): () => void {
    if (this._isElectron) {
      return this.electronService.onWindowStateChange(callback)
    } else {
      return () => {} // No-op unsubscribe for browser
    }
  }

  async showSaveDialog(defaultPath?: string): Promise<string | null> {
    if (this._isElectron) {
      return this.electronService.showSaveDialog(defaultPath)
    } else {
      return this.browserService.showSaveDialog(defaultPath)
    }
  }

  async showOpenDialog(): Promise<string[] | null> {
    if (this._isElectron) {
      return this.electronService.showOpenDialog()
    } else {
      return this.browserService.showOpenDialog()
    }
  }

  async showMessageBox(
    message: string,
    type: 'info' | 'warning' | 'error' = 'info',
  ): Promise<void> {
    if (this._isElectron) {
      return this.electronService.showMessageBox(message, type)
    } else {
      return this.browserService.showMessageBox(message, type)
    }
  }

  // Task Writer specific implementations
  async selectDirectory(): Promise<{ canceled: boolean; filePaths: string[] } | null> {
    if (this._isElectron) {
      return this.electronService.selectDirectory()
    } else {
      return this.browserService.selectDirectory()
    }
  }

  async scanDirectory(path: string, settings: any): Promise<{ tree: any[]; stats: any } | null> {
    if (this._isElectron) {
      return this.electronService.scanDirectory(path, settings)
    } else {
      return this.browserService.scanDirectory(path, settings)
    }
  }

  async exportScanResults(tree: any[], stats: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this._isElectron) {
      return this.electronService.exportScanResults(tree, stats)
    } else {
      return this.browserService.exportScanResults(tree, stats)
    }
  }

  async generateTasks(path: string, settings: any): Promise<{ tasks: any[]; stats: any } | null> {
    if (this._isElectron) {
      return this.electronService.generateTasks(path, settings)
    } else {
      return this.browserService.generateTasks(path, settings)
    }
  }

  async exportTasks(tasks: any[], format: string): Promise<{ success: boolean; directory: string } | null> {
    if (this._isElectron) {
      return this.electronService.exportTasks(tasks, format)
    } else {
      return this.browserService.exportTasks(tasks, format)
    }
  }

  async exportSingleTask(task: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this._isElectron) {
      return this.electronService.exportSingleTask(task)
    } else {
      return this.browserService.exportSingleTask(task)
    }
  }

  async generateScaffold(path: string, settings: any): Promise<{ scaffolds: any[]; stats: any } | null> {
    if (this._isElectron) {
      return this.electronService.generateScaffold(path, settings)
    } else {
      return this.browserService.generateScaffold(path, settings)
    }
  }

  async exportScaffolds(scaffolds: any[]): Promise<{ success: boolean; directory: string } | null> {
    if (this._isElectron) {
      return this.electronService.exportScaffolds(scaffolds)
    } else {
      return this.browserService.exportScaffolds(scaffolds)
    }
  }

  async exportSingleScaffold(scaffold: any): Promise<{ success: boolean; filePath: string } | null> {
    if (this._isElectron) {
      return this.electronService.exportSingleScaffold(scaffold)
    } else {
      return this.browserService.exportSingleScaffold(scaffold)
    }
  }
}

// Singleton instance
let platformServiceInstance: PlatformServiceImpl | null = null

export const getPlatformService = (): PlatformService => {
  if (!platformServiceInstance) {
    platformServiceInstance = new PlatformServiceImpl()
  }
  return platformServiceInstance
}

export const initializePlatformService = (): PlatformService => {
  platformServiceInstance = new PlatformServiceImpl()
  return platformServiceInstance
}

EOF

# Create searchService.ts
cat > "src/services/searchService.ts" << 'EOF'
import { getAppService } from './appService'
import { getAllNavigationItems } from '@/config/navigationConfig'

export class SearchService {
  
  /**
   * Navigate to a specific page/section based on search result
   * @param page - The page ID to navigate to
   * @param section - Optional section within the page
   */
  navigateToResult(page: string, section?: string): boolean {
    const appService = getAppService()
    if (!appService) {
      console.warn('AppService not initialized')
      return false
    }

    try {
      // Check if it's a valid navigation item
      const navigationItems = getAllNavigationItems()
      const navigationItem = navigationItems.find(item => item.id === page)
      
      if (navigationItem) {
        // Use the app service to properly open the tab
        const success = appService.openTab(page, true)
        
        if (success && section) {
          // For sections within pages, we could potentially add scroll-to logic
          // For phase 1, we just navigate to the page
          console.log(`Navigated to ${page}, section: ${section}`)
        }
        
        return success
      }

      // Handle special cases
      switch (page) {
        case 'welcome':
          // Navigate to welcome page by closing all tabs
          // The welcome page shows when no tabs are open
          return true

        case 'settings':
          // Use the dedicated settings method
          appService.openSettings()
          return true

        default:
          console.warn(`Unknown page: ${page}`)
          return false
      }
    } catch (error) {
      console.error('Error navigating to search result:', error)
      return false
    }
  }

  /**
   * Get the display name for a page ID
   * @param pageId - The page ID
   * @returns The display name or the ID if not found
   */
  getPageDisplayName(pageId: string): string {
    const navigationItems = getAllNavigationItems()
    const item = navigationItems.find(item => item.id === pageId)
    return item?.label || pageId
  }

  /**
   * Check if a page is currently available/accessible
   * @param pageId - The page ID to check
   * @returns True if the page can be navigated to
   */
  isPageAccessible(pageId: string): boolean {
    if (pageId === 'welcome' || pageId === 'settings') {
      return true
    }

    const navigationItems = getAllNavigationItems()
    return navigationItems.some(item => item.id === pageId)
  }
}

// Singleton instance
let searchServiceInstance: SearchService | null = null

export const getSearchService = (): SearchService => {
  if (!searchServiceInstance) {
    searchServiceInstance = new SearchService()
  }
  return searchServiceInstance
}

export const initializeSearchService = (): SearchService => {
  return getSearchService()
}
EOF

# Create tabService.ts
cat > "src/services/tabService.ts" << 'EOF'
import type { Tab } from '../types/tab'

export interface TabCallbacks {
  onTabAdd: (tab: Tab) => void
  onTabRemove: (tabId: string) => void
  onTabActivate: (tabId: string) => void
}

export class TabService {
  private callbacks: TabCallbacks

  constructor(callbacks: TabCallbacks) {
    this.callbacks = callbacks
  }

  addTab(tab: Tab): void {
    this.callbacks.onTabAdd(tab)
  }

  removeTab(tabId: string): void {
    this.callbacks.onTabRemove(tabId)
  }

  activateTab(tabId: string): void {
    this.callbacks.onTabActivate(tabId)
  }

  handleTabClick = (tabId: string): void => {
    this.activateTab(tabId)
  }

  handleTabClose = (tabId: string): void => {
    this.removeTab(tabId)
  }
}

let tabServiceInstance: TabService | null = null
export const getTabService = (): TabService | null => tabServiceInstance
export const initializeTabService = (callbacks: TabCallbacks): TabService => {
  tabServiceInstance = new TabService(callbacks)
  return tabServiceInstance
}

EOF


# Scaffold generation completed
echo "Scaffold generation completed successfully!"#!/bin/bash

#============================================================================
# Detox Tool Component Generator Script
# Category: core-services
# Description: Core services (AppService, TabService, NavigationService, SettingsService)
# Generated by: Task-Writer ScaffoldGenerator
# Implementation Phases: 1, 3
#============================================================================

# Create target directory structure
mkdir -p src/components/layout
mkdir -p src/components/ui
mkdir -p src/components/shared/forms
mkdir -p src/components/shared/generators
mkdir -p src/hooks
mkdir -p src/services
mkdir -p src/config
mkdir -p src/types

echo " Creating core-services for detox-tool..."
echo " Target: ./src/"
echo ""

